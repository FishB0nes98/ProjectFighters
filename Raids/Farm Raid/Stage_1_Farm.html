<!DOCTYPE html>
<html lang="en">
    <script type="module">
        import { initializeApp } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js';
        import { getDatabase, ref, get, set, update } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-database.js';
        import { getAuth, onAuthStateChanged } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-auth.js';
        import ITEM_DATABASE from '../../ItemDatabase.js';

        const firebaseConfig = {
            apiKey: "AIzaSyCqhxq6sPDU3EmuvvkBIIDJ-H6PsBc42Jg",
            authDomain: "project-fighters-by-fishb0nes.firebaseapp.com",
            databaseURL: "https://project-fighters-by-fishb0nes-default-rtdb.europe-west1.firebasedatabase.app",
            projectId: "project-fighters-by-fishb0nes",
            storageBucket: "project-fighters-by-fishb0nes.appspot.com",
            messagingSenderId: "867339299995",
            appId: "1:867339299995:web:99c379940014b9c05cea3e",
            measurementId: "G-LNEM6HR842"
        };

        // Initialize Firebase
        const app = initializeApp(firebaseConfig);
        const db = getDatabase(app);
        const auth = getAuth(app);

        // Make these available to the global scope
        window.db = db;
        window.auth = auth;
        window.ITEM_DATABASE = ITEM_DATABASE;
        window.dbRef = ref;
        window.dbGet = get;
        window.dbSet = set;      // Add this line
        window.dbUpdate = update;

        // Remove the auth state listener that might be causing double initialization
        // Only initialize game when start button is clicked
        window.startGame = async function() {
            // Prevent double initialization
            if (window.gameInitialized) {
                console.log('Game already initialized, skipping...');
                return;
            }

            document.getElementById('start-button').style.display = 'none';
            
            // Check if user is logged in
            const user = auth.currentUser;
            if (!user) {
                console.error('No user logged in');
                return;
            }

            // Clear existing inventory first
            inventory.slots = new Array(6).fill(null);
            updateInventoryDisplay();

            // Initialize turn counter to 1 instead of 0
            turnCounter = 1;
            document.getElementById('turn-counter').innerText = `Turn: ${turnCounter}`;
            logEnemyAction(`\n--- Turn ${turnCounter} ---`);

            // Load user's raid inventory (single load)
            try {
                const inventoryRef = dbRef(db, `users/${user.uid}/RaidInventory/items`);
                const snapshot = await dbGet(inventoryRef);
                
                console.log('Loading inventory...'); // Debug log
                
                if (snapshot.exists()) {
                    const items = snapshot.val();
                    console.log('Inventory data:', items);
                    
                    // Add each item to the inventory with its full count
                    for (const [itemId, count] of Object.entries(items)) {
                        if (count > 0 && ITEM_DATABASE[itemId]) {
                            console.log(`Adding item to inventory: ${itemId}, count: ${count}`);
                            addItemToInventory({
                                ...ITEM_DATABASE[itemId],
                                count: count
                            }, true);
                        }
                    }
                }
            } catch (error) {
                console.error('Error loading inventory:', error);
            }

            enableAbilities();
            isPlayerTurn = true;
            window.gameInitialized = true;
            updateDamageBonus(); // Initialize damage bonus display

            weakerCarrotsSpawned = false; // Reset the flag
            itemCooldowns = {};  // Reset all cooldowns
            isFirstTurn = true;
        }
    </script>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Farm Raid - Stage 1</title>
    <style>
        /* Add this at the top of your CSS */
        @import url('https://fonts.googleapis.com/css2?family=Nunito:wght@400;600;700&display=swap');

        /* Update the base styles */
        body {
            font-family: 'Nunito', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, 
                         "Helvetica Neue", Arial, "Noto Sans", sans-serif, 
                         "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji";
            margin: 0;
            padding: 0;
            background: url('res/Stage_1_BG.jpeg') no-repeat center center fixed;
            background-size: cover;
            color: #ffffff;
        }

        /* Update title positioning without background */
        h1 {
            position: fixed;
            top: 20px;
            right: 20px;
            margin: 0;
            font-size: 24px;
            z-index: 100;
        }

        .character {
            display: inline-block;
            position: absolute;
            bottom: 120px;
            width: 250px;
            height: 350px;
        }

        .farmer-cham-cham {
            left: 43%;
        }

        .enemy {
            display: inline-block;
            position: absolute;
            top: 50px;
            width: 250px;
            height: 350px;
            right: 44%;
        }

        .character img, .enemy img {
            width: 250px;
            height: 350px;
        }

        /* Restore and update HP bar styling */
        .status {
            position: relative;
            width: 250px;
            margin-top: 10px;
        }

        .hp-bar-container {
            width: 100%;
            height: 20px;
            background-color: #333;
            border: 2px solid #000;
            border-radius: 10px;
            overflow: hidden;
            position: relative;
        }

        /* Update HP text positioning */
        [id$="-status"] {  /* Targets all elements ending with "-status" */
            position: absolute;
            width: 100%;
            height: 20px;  /* Match height of hp-bar-container */
            top: 2px;        /* Align with top of hp-bar-container */
            left: 0;       /* Align with left of hp-bar-container */
            display: flex;
            align-items: center;     /* Vertical centering */
            justify-content: center; /* Horizontal centering */
            text-align: center;
            z-index: 2;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
            pointer-events: none;
            margin: 0;
            padding: 0;
        }

        /* Ensure HP bar is behind the text */
        .hp-bar {
            width: 100%;
            height: 100%;
            background-color: #4CAF50;
            transition: width 0.3s ease-out;
            position: absolute;
            z-index: 1;
        }

        .buff-container {
            position: absolute;
            top: 5px;
            left: 5px;
            display: flex;
            gap: 5px;
        }

        .buff-icon {
            width: 50px !important;
            height: 50px !important;
            margin: 0 1px;
            display: inline-block;
        }

        .log-container {
            width: 400px;
            height: 200px;
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.85);
            border: 2px solid #666;
            border-radius: 10px;
            padding: 10px;
            overflow-y: auto;
            z-index: 1000;
            font-size: 14px;
            line-height: 1.5;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
        }

        #log p {
            margin: 5px 0;
            padding: 3px 5px;
            border-radius: 4px;
            transition: background-color 0.2s;
        }

        #log p:hover {
            background-color: rgba(255, 255, 255, 0.1);
        }

        .turn-counter {
            position: absolute;
            top: 5px;
            right: 925px;
            z-index: 10;
            font-size: 18px;
            color: white;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 5px 10px;
            border-radius: 5px;
        }

        #start-button {
            position: absolute;
            top: 48%;
            left: 50%;
            transform: translate(-50%, -50%);
            padding: 10px 20px;
            font-size: 20px;
            cursor: pointer;
        }

        .ability-container {
            position: relative;
            display: flex;
            justify-content: center;
            margin-top: 5px;
        }

        .ability {
            width: 50px;
            height: 50px;
            margin: 6px;
            cursor: pointer;
            position: relative;
        }

        .ability img {
            width: 50px;
            height: 50px;
        }

        .cooldown-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: red;
            font-size: 35px;
            font-weight: bold;
            pointer-events: none;
            z-index: 1;
            text-shadow: 
                -1px -1px 0 #000,  
                 1px -1px 0 #000,
                -1px  1px 0 #000,
                 1px  1px 0 #000;
        }

        .disabled {
            filter: grayscale(100%);
            pointer-events: none;
            opacity: 0.5;
        }

        #volume-control {
            position: absolute;
            bottom: 10px;
            left: 10px;
            color: white;
            display: flex;
            align-items: center;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 5px 10px;
            border-radius: 5px;
        }

        #volume-slider {
            margin-left: 10px;
        }

        .flash-red {
            filter: brightness(100%) sepia(100%) saturate(10000%) hue-rotate(0deg) opacity(0.7);
        }

        .flash-green {
            filter: brightness(100%) sepia(100%) saturate(10000%) hue-rotate(100deg) opacity(0.7);
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .spin-effect {
            animation: spin 1s ease-in-out;
        }

        @keyframes throw-boomerang {
            0% { transform: translate(0, 0) rotate(0deg); }
            100% { transform: translate(0, -600px) rotate(360deg); } /* Move vertically up */
        }

        @keyframes return-boomerang {
            0% { transform: translate(0, -600px) rotate(360deg); } /* Start at top */
            100% { transform: translate(0, 0) rotate(720deg); } /* Return to Cham Cham */
        }

        .boomerang-throw {
            animation: throw-boomerang 1s forwards;
        }

        .boomerang-return {
            animation: return-boomerang 1s forwards;
        }

        .enemy-info {
            position: fixed;
            z-index: 1000;
            background-color: #2a2a2a;
            min-width: 300px;
            min-height: 200px;
            width: 300px;
            height: 200px;
            resize: both;
            overflow: auto;
            border: 1px solid #888;
            border-radius: 10px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
        }

        .enemy-info-content {
            padding: 20px;
            height: calc(100% - 40px);
            cursor: move;
            overflow: auto;
            font-family: 'Nunito', sans-serif;
        }

        .enemy-info-content h2 {
            font-weight: 700;
        }

        .enemy-info-content h3 {
            font-weight: 600;
        }

        /* Add a visible resize handle */
        .enemy-info::after {
            content: '';
            position: absolute;
            bottom: 0;
            right: 0;
            width: 15px;
            height: 15px;
            cursor: se-resize;
            background: 
                linear-gradient(45deg, transparent 50%, #888 50%),
                linear-gradient(-45deg, transparent 50%, #888 50%);
            background-size: 8px 8px;
            background-position: right bottom;
            background-repeat: no-repeat;
        }

        /* Ensure content stays within bounds when resizing */
        .ability-info {
            margin: 15px 0;
            padding: 10px;
            background-color: #3a3a3a;
            border-radius: 5px;
            word-wrap: break-word;
        }

        .close-button {
            color: #aaa;
            float: right;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
            position: absolute;
            right: 20px;
            top: 10px;
        }

        .close-button:hover {
            color: #fff;
        }

        /* Resize handle style */
        .enemy-info {
            resize: both;
        }

        /* Remove the full-screen overlay */
        .enemy-info {
            width: 374px;
            height: 700px;
        }

        /* Make the enemy image clickable */
        #AngryCarrot img {
            cursor: pointer;
        }

        #WeakerCarrotsContainer {
            position: absolute;
            top: 20px;
            right: 42%;
            display: flex;
            gap: 50px;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: scale(0.8);
            }
            to {
                opacity: 1;
                transform: scale(1);
            }
        }

        @keyframes fadeOut {
            from {
                opacity: 1;
                transform: scale(1);
            }
            to {
                opacity: 0;
                transform: scale(0.8);
            }
        }

        .weaker-carrot {
            animation: fadeIn 0.5s ease-out;
            position: absolute;
            top: 50px;  /* Adjust as needed */
            left: 50%;  /* Center horizontally */
            transform: translateX(-50%);  /* Center the element */
        }

        .weaker-carrot.fade-in {
            animation: fadeIn 0.8s ease-out forwards;
        }

        .weaker-carrot.fade-out {
            animation: fadeOut 0.5s ease-in forwards;
        }

        .weaker-carrot:nth-child(1) {
            left: 35%;  /* Adjust for horizontal positioning */
        }

        .weaker-carrot:nth-child(2) {
            left: 45%;
        }

        .weaker-carrot:nth-child(3) {
            left: 55%;
        }

        #targeting-container {
            position: absolute;
            bottom: 20px;
            left: 85px;
            display: flex;
            gap: 10px;
            z-index: 1000;
        }

        #targeting-container img.target-icon {
            width: 50px !important;
            height: 50px !important;
            cursor: pointer;
            border: 2px solid #ffd700;
            border-radius: 5px;
            transition: transform 0.2s;
            object-fit: contain;
        }

        #targeting-container img.target-icon:hover {
            transform: scale(1.1);
            border-color: #ff0000;
        }

        .inventory {
            position: absolute;
            left: 35px;
            bottom: 60px;
            width: 200px;
            background-color: rgba(0, 0, 0, 0.7);
            border: 2px solid #555;
            border-radius: 10px;
            padding: 10px;
        }

        .inventory h3 {
            color: white;
            text-align: center;
            margin: 0 0 10px 0;
        }

        .inventory-slots {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            padding: 5px;
        }

        .inventory-slot {
            width: 80px;
            height: 80px;
            border: 2px solid #ffd700;
            border-radius: 5px;
            background-color: rgba(0, 0, 0, 0.5);
            cursor: pointer;
            transition: all 0.2s ease;
            position: relative;
        }

        .inventory-slot:hover {
            border-color: #fff;
            transform: scale(1.05);
        }

        .inventory-slot img {
            width: 100%;
            height: 100%;
            object-fit: contain;
        }

        .inventory-slot .item-count {
            position: absolute;
            bottom: 2px;
            right: 2px;
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 2px 5px;
            border-radius: 3px;
            font-size: 12px;
        }

        /* Tooltip for inventory items */
        .inventory-slot[data-tooltip] {
            position: relative;
        }

        .inventory-slot[data-tooltip]:hover::after {
            content: attr(data-tooltip);
            position: absolute;
            left: 50%;
            top: -35px;
            transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 14px;
            white-space: nowrap;
            z-index: 1000;
        }

        #item-targeting-container {
            position: absolute;
            top: -60px;  /* Position above the inventory */
            left: 50%;   /* Center horizontally */
            transform: translateX(-50%);
            display: flex;
            gap: 10px;
            z-index: 1000;
        }

        #item-targeting-container .target-icon {
            width: 50px !important;
            height: 50px !important;
            cursor: pointer;
            border: 2px solid #00ff00;
            border-radius: 5px;
            transition: transform 0.2s;
            object-fit: contain;
        }

        #item-targeting-container .target-icon:hover {
            transform: scale(1.1);
            border-color: #00ffaa;
        }

        .inventory-slot {
            cursor: pointer;
            position: relative;
        }

        .inventory-slot.usable:hover {
            border-color: #00ff00;
        }

        .drop-window {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            padding: 20px;
            border-radius: 10px;
            z-index: 1000;
        }

        .drop-content {
            text-align: center;
        }

        .drop-items {
            margin: 20px 0;
        }

        .drop-item {
            display: flex;
            align-items: center;
            margin: 10px;
            padding: 10px;
            border-radius: 5px;
        }

        .drop-item img {
            width: 40px;
            height: 40px;
            margin-right: 10px;
        }

        .item-info {
            display: flex;
            flex-direction: column;
            align-items: flex-start;
        }

        .rarity-common {
            background: rgba(200, 200, 200, 0.2);
        }

        .rarity-rare {
            background: rgba(0, 112, 221, 0.2);
            border: 1px solid #0070dd;
        }

        .rarity-legendary {
            background: rgba(255, 128, 0, 0.2);
            border: 1px solid #ff8000;
        }

        .collect-button {
            padding: 10px 20px;
            background: #4CAF50;
            border: none;
            border-radius: 5px;
            color: white;
            cursor: pointer;
        }

        .collect-button:hover {
            background: #45a049;
        }

        .buff-container {
            position: absolute;
            top: 5px;
            left: 5px;
            display: flex;
            gap: 5px;
            z-index: 1000;
            flex-direction: row; /* Ensure horizontal layout */
        }
        
        .buff-icon {
            width: 30px;
            height: 30px;
            position: relative;
            border: 2px solid #ff00ff;
            border-radius: 5px;
            background: rgba(0, 0, 0, 0.7);
            overflow: hidden;
        }
        
        .buff-icon img {
            width: 100%;
            height: 100%;
            object-fit: contain;
        }
        
        .buff-duration {
            position: absolute;
            bottom: 0;
            right: 0;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 1px 3px;
            font-size: 10px;
            border-top-left-radius: 3px;
            font-family: 'Nunito', sans-serif;
            font-weight: 700;
        }

        .character img.flash-red, .enemy img.flash-red {
            filter: brightness(100%) sepia(100%) saturate(10000%) hue-rotate(0deg) opacity(0.7);
        }

        .character img.flash-green, .enemy img.flash-green {
            filter: brightness(100%) sepia(100%) saturate(10000%) hue-rotate(0deg) opacity(0.7);
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(-20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        

        .weaker-carrot {
            animation: fadeIn 0.5s ease-out;
            position: absolute;
            top: 50px;  /* Adjust as needed */
            left: 50%;  /* Center horizontally */
            transform: translateX(-50%);  /* Center the element */
        }

        .weaker-carrot:nth-child(1) {
            left: 20%;
        }

        .weaker-carrot:nth-child(2) {
            left: 45%;
        }

        .weaker-carrot:nth-child(3) {
            left: 70%;
        }

        .weaker-carrots-container {
            display: flex;
            justify-content: space-around; /* Adjust as needed */
            margin-top: 20px; /* Adjust spacing as needed */
        }

        /* Existing styles for .weaker-carrot */
        .enemy.weaker-carrot {
            /* Your existing styles */
            position: relative;
            /* Add any additional styling needed */
        }

        .damage-bonus {
            position: absolute;
            bottom: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.8);
            color: #ff4444;
            padding: 5px 10px;
            border-radius: 15px;
            font-size: 14px;
            font-weight: 700;
            border: 2px solid #ff6666;
            box-shadow: 0 0 10px rgba(255, 68, 68, 0.5);
            z-index: 10;
            display: flex;
            align-items: center;
            gap: 5px;
            font-family: 'Nunito', sans-serif;
        }

        .damage-bonus::before {
            content: '⚔️';
            font-size: 16px;
        }

        @keyframes damageUpdate {
            0% { transform: scale(1); }
            50% { transform: scale(1.2); }
            100% { transform: scale(1); }
        }

        .damage-update {
            animation: damageUpdate 0.3s ease-out;
        }

        /* Update log styles for turn indicator */
        #log p.turn-indicator {
            background-color: rgba(255, 255, 0, 0.15);
            border-left: 3px solid #ffff00;
            padding-left: 8px;
            margin: 10px 0;
        }

        /* Update cooldown text styling */
        .inventory-slot {
            position: relative;
        }

        .inventory-slot.on-cooldown {
            position: relative;
        }

        .inventory-slot.on-cooldown::after {
            content: attr(data-cooldown);
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #ff0000;
            font-size: 24px;
            font-weight: bold;
            text-shadow: 
                -1px -1px 0 #000,
                 1px -1px 0 #000,
                -1px  1px 0 #000,
                 1px  1px 0 #000;
            z-index: 2;
        }

        .inventory-slot.on-cooldown img {
            opacity: 0.5;
        }

        /* Add cooldown overlay styling for inventory slots */
        .inventory-slot {
            position: relative;
        }

        .cooldown-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            pointer-events: none;
        }

        .cooldown-text {
            color: white;
            font-size: 24px;
            font-weight: bold;
            text-shadow: 2px 2px 2px rgba(0, 0, 0, 0.8);
        }
    </style>
</head>
<body>
    <h1 style="position: relative; left: 1%;">Farm Raid - Stage 1</h1>
    <div id="enemy-area">
        <div id="AngryCarrot" class="enemy">
            <img src="res/Angry_Carrot.jpeg" alt="Angry Carrot">
            <div class="buff-container" id="AngryCarrot-buff-container"></div>
            <div class="status">
                <div class="hp-bar-container">
                    <div class="hp-bar" id="AngryCarrot-hp-bar"></div>
                </div>
                <div id="AngryCarrot-status">HP: 12500/12500</div>
            </div>
        </div>
        <!-- Weaker Carrots Container -->
        <div id="WeakerCarrotsContainer" class="weaker-carrots-container">
            <!-- Weaker Angry Carrots will be appended here -->
        </div>
    </div>
    <div class="character farmer-cham-cham" id="FarmerChamCham">
        <img src="../../Loading Screen/Farmer Cham Cham.png" alt="Farmer Cham Cham">
        <div class="status">
            <div class="hp-bar-container">
                <div class="hp-bar" id="FarmerChamCham-hp-bar"></div>
            </div>
            <div id="FarmerChamCham-status">HP: 8750/8750</div>
        </div>
        <div class="buff-container" id="FarmerChamCham-buff-container"></div>
        <div class="damage-bonus" id="scratch-damage-bonus">+0</div>
        <div class="ability-container" id="FarmerChamCham-abilities">
            <div class="ability">
                <img id="ChamChamAbility1" src="res/Cham_A1.jpeg" alt="Scratch" 
                    title="Scratch: Deals 100 damage. Each use permanently increases damage by 50.">
                <div id="ChamChamAbility1Cooldown" class="cooldown-text" style="display: none;"></div>
            </div>
            <div class="ability">
                <img id="ChamChamAbility2" src="res/Cham_A2.jpeg" alt="Leap" 
                    title="Leap: Take 25% more damage but heal for 115% of damage dealt for 3 turns.">
                <div id="ChamChamAbility2Cooldown" class="cooldown-text" style="display: none;"></div>
            </div>
            <div class="ability">
                <img id="ChamChamAbility3" src="res/Cham_A3.jpeg" alt="Catboomerang" 
                    title="Catboomerang: Deals damage equal to current Scratch damage. Has a 50% chance to hit again and increase Scratch damage.">
                <div id="ChamChamAbility3Cooldown" class="cooldown-text" style="display: none;"></div>
            </div>
            <div class="ability">
                <img id="ChamChamAbility4" src="res/Cham_A4.jpeg" alt="Wild Strike" 
                    title="Wild Strike: Unleashes 4 consecutive Scratches, each hit scaling with Scratch's damage increase.">
                <div id="ChamChamAbility4Cooldown" class="cooldown-text" style="display: none;"></div>
            </div>
        </div>
    </div>
    <button id="start-button">Start Stage 1</button>
    <div class="log-container" id="log"></div>
    <div class="turn-counter" id="turn-counter">Turn: 0</div>
    <div id="volume-control">
        <label for="volume-slider">Volume:</label>
        <input type="range" id="volume-slider" min="0" max="100" value="20">
    </div>
    <img id="boomerang" src="res/boomerang.png" alt="Boomerang" style="display: none; position: absolute; width: 200px; height: 200px;">
    <div id="enemy-info" class="enemy-info" style="display: none;">
        <div class="enemy-info-content">
            <span class="close-button">&times;</span>
            <h2>Angry Carrot Abilities</h2>
            <div class="ability-info">
                <h3>Carrot Cannon (65% chance)</h3>
                <p>Deals 500 damage. If Anger buff is active, deals triple damage.</p>
            </div>
            <div class="ability-info">
                <h3>Anger (10% chance)</h3>
                <p>Applies a buff that triples all damage for 5 turns.</p>
            </div>
            <div class="ability-info">
                <h3>Dormant (10% chance)</h3>
                <p>Heals 2250 HP and skips turns for 2 turns.</p>
            </div>
            <div class="ability-info">
                <h3>Carrot Bomb (15% chance)</h3>
                <p>Deals 500 damage and heals for the same amount. If Anger buff is active, deals and heals for triple damage.</p>
            </div>
        </div>
    </div>
    <div class="inventory">
        <h3>Inventory</h3>
        <div class="inventory-slots">
            <div class="inventory-slot" data-slot="1"></div>
            <div class="inventory-slot" data-slot="2"></div>
            <div class="inventory-slot" data-slot="3"></div>
            <div class="inventory-slot" data-slot="4"></div>
            <div class="inventory-slot" data-slot="5"></div>
            <div class="inventory-slot" data-slot="6"></div>
        </div>
    </div>
    <script>
        // Update initial scratch damage
        let chamChamScratchDamage = 100;  // Changed from 200 to 100

        let lastUsedAbility = null;
        let isPlayerTurn = false;
        let buffs = {
            FarmerChamCham: {},
            AngryCarrot: {}
        };
        let turnCounter = 0;
        let bgAudio = null;
        let selectedAbility = null;
        let targetingActive = false;
        let isUsingItem = false;

        const abilityCooldowns = {
            'ChamChamAbility1': { current: 0, max: 0 },
            'ChamChamAbility2': { current: 0, max: 8 },
            'ChamChamAbility3': { current: 0, max: 10 }, // Updated from 3 to 10
            'ChamChamAbility4': { current: 0, max: 23 }
        };

        const inventory = {
            slots: new Array(6).fill(null),
            maxStack: 99
        };

        let activeEnemies = 0; // Tracks the number of enemies that need to act each turn

        // Add a flag to track if weaker carrots have been spawned
        let weakerCarrotsSpawned = false;

        // Change from const to let for itemCooldowns
        let itemCooldowns = {};

        // Add this at the top with your other global variables
        const droppedLoot = new Set();

        async function startGame() {
            // Prevent double initialization
            if (window.gameInitialized) {
                console.log('Game already initialized, skipping...');
                return;
            }
            
            document.getElementById('start-button').style.display = 'none';
            
            // Check if user is logged in
            const user = auth.currentUser;
            if (!user) {
                console.error('No user logged in');
                return;
            }

            // Clear existing inventory first
            inventory.slots = new Array(6).fill(null);
            updateInventoryDisplay();

            // Initialize turn counter to 1 instead of 0
            turnCounter = 1;
            document.getElementById('turn-counter').innerText = `Turn: ${turnCounter}`;
            logEnemyAction(`\n--- Turn ${turnCounter} ---`);

            // Load user's raid inventory (single load)
            try {
                const inventoryRef = dbRef(db, `users/${user.uid}/RaidInventory/items`);
                const snapshot = await dbGet(inventoryRef);
                
                console.log('Loading inventory...'); // Debug log
                
                if (snapshot.exists()) {
                    const items = snapshot.val();
                    console.log('Inventory data:', items);
                    
                    // Add each item to the inventory with its full count
                    for (const [itemId, count] of Object.entries(items)) {
                        if (count > 0 && ITEM_DATABASE[itemId]) {
                            console.log(`Adding item to inventory: ${itemId}, count: ${count}`);
                            addItemToInventory({
                                ...ITEM_DATABASE[itemId],
                                count: count
                            }, true);
                        }
                    }
                }
            } catch (error) {
                console.error('Error loading inventory:', error);
            }

            enableAbilities();
            isPlayerTurn = true;
            

            // Stop any existing audio
            if (bgAudio) {
                bgAudio.pause();
                bgAudio = null;
            }
            
            // Create and configure new audio
            bgAudio = new Audio('res/Stage_1_Audio.mp3');
            bgAudio.volume = document.getElementById('volume-slider').value / 100;
            bgAudio.loop = true;
            
            // Only start playing after loading
            bgAudio.addEventListener('canplaythrough', function() {
                bgAudio.play().catch(function(error) {
                    console.log("Audio play failed:", error);
                });
            }, { once: true }); // Use once: true to ensure the event listener is removed after first use

            // Mark game as initialized
            window.gameInitialized = true;
            updateDamageBonus(); // Initialize damage bonus display

            weakerCarrotsSpawned = false; // Reset the flag
            itemCooldowns = {};  // Reset all cooldowns
            isFirstTurn = true;
        }

        function applyFlashEffect(character) {
            const characterElement = document.getElementById(character);
            if (characterElement) {
                const characterImage = characterElement.querySelector('img');
                if (characterImage) {
                    // Remove any existing flash classes
                    characterImage.classList.remove('flash-green');
                    characterImage.classList.add('flash-red');
                    setTimeout(() => {
                        characterImage.classList.remove('flash-red');
                    }, 200);
                }
            }
        }
        

        function applyGreenFlashEffect(character) {
            const characterElement = document.getElementById(character);
            if (characterElement) {
                const characterImage = characterElement.querySelector('img');
                if (characterImage) {
                    // Remove any existing flash classes
                    characterImage.classList.remove('flash-red');
                    characterImage.classList.add('flash-green');
                    setTimeout(() => {
                        characterImage.classList.remove('flash-green');
                    }, 200);
                }
            }
        }
        

        // Update the updateCharacterStatus function to use flash-red for damage
        function updateCharacterStatus(character, damage) {
            const statusElement = document.getElementById(`${character}-status`);
            const hpBarElement = document.getElementById(`${character}-hp-bar`);

            if (!statusElement || !hpBarElement) {
                console.error(`Element not found for character: ${character}`);
                return;
            }

            let currentHp = parseInt(statusElement.innerText.split('/')[0].split(': ')[1]);
            const maxHp = parseInt(statusElement.innerText.split('/')[1]);

            // Apply increased damage if the "Leap" buff is active
            if (character === 'FarmerChamCham' && buffs['FarmerChamCham']['increasedDamage'] > 0) {
                damage *= 1.25; // Increase damage taken by 25%
            }

            currentHp -= Math.floor(damage);
            if (currentHp < 0) currentHp = 0;

            statusElement.innerText = `HP: ${currentHp}/${maxHp}`;

            const hpPercentage = (currentHp / maxHp) * 100;
            hpBarElement.style.width = `${hpPercentage}%`;

            // Apply red flash effect for damage
            applyFlashEffect(character);

            const log = document.getElementById('log');
            const logEntry = document.createElement('p');
            logEntry.innerHTML = `<span style="color: yellow;">Turn ${turnCounter}:</span> <span style="color: red;">${character} took ${Math.floor(damage)} damage!</span>`;
            log.appendChild(logEntry);
            scrollToBottom();

            // Check if the main Angry Carrot should split
            if (character === 'AngryCarrot' && currentHp <= 0 && !weakerCarrotsSpawned) {
                weakerCarrotsSpawned = true; // Set flag to prevent multiple spawns
                angryCarrot.style.display = 'none';
                
                // Spawn weaker carrots
                spawnWeakerCarrots();
                
                const log = document.getElementById('log');
                const logEntry = document.createElement('p');
                logEntry.innerHTML = `<span style="color: yellow;">⚡ Event:</span> <span style="color: #ff0000;">Angry Carrot splits into three weaker versions!</span>`;
                log.appendChild(logEntry);
                scrollToBottom();
            } else if (character.startsWith('WeakerCarrot')) {
                const carrotNumber = character.replace('WeakerCarrot', '');
                checkWeakCarrotHealth(carrotNumber);
            }
        }

        // Update the useScratch function to handle damage scaling
        function useScratch(targetId) {
            if (!isPlayerTurn) return;

            disableAbilities();

            let damage = chamChamScratchDamage;
            updateCharacterStatus(targetId, damage);
            logAction('Farmer Cham Cham', 'Scratch', targetId, `deals ${damage} damage`);

            // Calculate healing with modifiers
            const healAmount = calculateHealingWithModifiers(damage, 'FarmerChamCham');
            if (healAmount > damage) {
                healCharacter('FarmerChamCham', healAmount);
            }

            // Increase damage for next Scratch
            chamChamScratchDamage += 50;
            updateDamageBonus();
            lastUsedAbility = 'Scratch';

            isPlayerTurn = false;
            setTimeout(carrotTurn, 2000);
        }
        
        function useCatboomerang(targetId) {
            if (!isPlayerTurn) return;

            disableAbilities();
            startCooldown('ChamChamAbility3');

            const boomerang = document.getElementById('boomerang');
            boomerang.style.display = 'block';
            boomerang.style.left = '43%';
            boomerang.style.bottom = '150px';
            boomerang.classList.add('boomerang-throw');

            // First hit using current Scratch damage
            setTimeout(() => {
                boomerang.classList.remove('boomerang-throw');
                boomerang.style.transform = 'translate(0, -600px) rotate(360deg)';
                let damage = chamChamScratchDamage;
                updateCharacterStatus(targetId, damage);
                logAction('Farmer Cham Cham', 'Catboomerang', targetId, `deals ${damage} damage`);

                // Calculate healing with modifiers
                const healAmount = calculateHealingWithModifiers(damage, 'FarmerChamCham');
                if (healAmount > damage) {
                    healCharacter('FarmerChamCham', healAmount);
                }

                // Check if target is still alive
                if (targetId === 'AngryCarrot') {
                    checkCarrotHealth();
                } else {
                    checkWeakCarrotHealth(parseInt(targetId.replace('WeakerCarrot', '')));
                }

                const targetElement = document.getElementById(`${targetId}-status`);
                const currentHp = targetElement ? parseInt(targetElement.innerText.split('/')[0].split(': ')[1]) : 0;
                const additionalHit = Math.random() < 0.5 && currentHp > 0;

                if (additionalHit) {
                    // Second hit
                    setTimeout(() => {
                        boomerang.classList.add('boomerang-return');
                        setTimeout(() => {
                            updateCharacterStatus(targetId, damage);
                            logAction('Farmer Cham Cham', 'Catboomerang', targetId, `deals additional ${damage} damage`);

                            // Recalculate healing for the second hit
                            const healAmountSecond = calculateHealingWithModifiers(damage, 'FarmerChamCham');
                            if (healAmountSecond > damage) {
                                healCharacter('FarmerChamCham', healAmountSecond);
                            }

                            // Check if target is still alive after second hit
                            if (targetId === 'AngryCarrot') {
                                checkCarrotHealth();
                            } else {
                                checkWeakCarrotHealth(parseInt(targetId.replace('WeakerCarrot', '')));
                            }

                            boomerang.style.display = 'none';
                            isPlayerTurn = false;
                            setTimeout(carrotTurn, 1000);
                            chamChamScratchDamage += 50;
                            updateDamageBonus();
                        }, 1000);
                    }, 1000);
                } else {
                    // No second hit
                    if (currentHp <= 0) {
                        logAction('Farmer Cham Cham', 'Catboomerang', targetId, 'target died, additional hit skipped');
                    } else {
                        logAction('Farmer Cham Cham', 'Catboomerang', targetId, 'missed additional hit');
                    }
                    boomerang.style.display = 'none';
                    isPlayerTurn = false;
                    setTimeout(carrotTurn, 1000);
                }
            }, 1000);

            // Double-check abilities after the action
            setTimeout(doubleCheckAbilities, 1500);
        }

        // Update useWildStrike to handle drops only once
        function useWildStrike(targetId) {
            if (!isPlayerTurn) return;

            disableAbilities();
            let dropsGiven = false;  // Flag to track if drops have been given

            const numberOfHits = 4;
            for (let i = 0; i < numberOfHits; i++) {
                let damage = chamChamScratchDamage;
                
                // For the last hit, we'll handle drops normally
                if (i === numberOfHits - 1) {
                    updateCharacterStatus(targetId, damage);
                } else {
                    // For all other hits, we'll prevent drops
                    const currentElement = document.getElementById(targetId);
                    if (currentElement && currentElement.style.display !== 'none') {
                        // Temporarily store the handleDrops function
                        const originalHandleDrops = window.handleDrops;
                        window.handleDrops = () => {};  // Replace with empty function
                        
                        updateCharacterStatus(targetId, damage);
                        
                        // Restore the original handleDrops function
                        window.handleDrops = originalHandleDrops;
                    }
                }

                logAction('Farmer Cham Cham', 'Wild Strike', targetId, `hit ${i + 1}: deals ${damage} damage`);

                // Calculate healing with modifiers for each hit
                const healAmount = calculateHealingWithModifiers(damage, 'FarmerChamCham');
                if (healAmount > damage) {
                    healCharacter('FarmerChamCham', healAmount);
                }

                chamChamScratchDamage += 50;
                updateDamageBonus();
            }

            lastUsedAbility = 'WildStrike';
            isPlayerTurn = false;
            setTimeout(carrotTurn, 2000);
        }

        function applyHealingWithBuffs(character, baseHealAmount) {
            let healAmount = baseHealAmount;

            // Check for healing amplifier buff
            if (buffs[character] && buffs[character]['healing_amplifier']) {
                const amplifier = buffs[character]['healing_amplifier'].value;
                healAmount *= (1 + amplifier); // Apply the healing bonus
            }

            // Check for increased damage buff from Leap
            if (buffs[character] && buffs[character]['increasedDamage']) {
                const leapBonus = 0.15; // 15% additional healing from Leap
                healAmount *= (1 + leapBonus);
            }

            healCharacter(character, healAmount);
        }

        // Update the carrotTurn function to only handle weaker carrots
        function carrotTurn() {
            turnCounter++;
            document.getElementById('turn-counter').innerText = `Turn: ${turnCounter}`;
            logEnemyAction(`\n--- Turn ${turnCounter} ---`);
            
            // Update buffs for all characters at the start of turn
            updateBuffs();
            updateCooldowns();
            
            // Reset activeEnemies count
            activeEnemies = 0;

            // Check main carrot
            const mainCarrot = document.getElementById('AngryCarrot');
            if (mainCarrot && mainCarrot.style.display !== 'none') {
                activeEnemies++;
                // Skip turn if dormant
                if (buffs['AngryCarrot'] && buffs['AngryCarrot']['dormant']) {
                    logAction('Angry Carrot', 'Dormant', 'self', 'is sleeping and skips its turn');
                    activeEnemies--;
                } else {
                    setTimeout(() => mainCarrotAI(), 1000);
                }
            }

            // Handle weaker carrots turns
            for (let i = 1; i <= 3; i++) {
                const carrotId = `WeakerCarrot${i}`;
                const carrot = document.getElementById(carrotId);
                if (carrot && carrot.style.display !== 'none') {
                    activeEnemies++;
                    // Skip turn if dormant
                    if (buffs[carrotId] && buffs[carrotId]['dormant']) {
                        logAction(`Weaker Angry Carrot ${i}`, 'Dormant', 'self', 'is sleeping and skips its turn');
                        activeEnemies--;
                    } else {
                        setTimeout(() => weakerCarrotAI(i), i * 1000);
                    }
                }
            }
            
            // If no active enemies or all are dormant, end turn and start player's turn
            if (activeEnemies === 0) {
                isPlayerTurn = true;
                enableAbilities();
                logPlayerTurn();
            }
        }

        // Function to log player turn
        function logPlayerTurn() {
            const log = document.getElementById('log');
            const logEntry = document.createElement('p');
            logEntry.innerHTML = `<span style="color: #00ff00;">👉 Your turn!</span>`;
            log.appendChild(logEntry);
            scrollToBottom();
        }

        // Function to log enemy actions (for debugging)
        function logEnemyAction(message) {
            const log = document.getElementById('log');
            const logEntry = document.createElement('p');
            
            if (message.includes('Turn')) {
                logEntry.classList.add('turn-indicator');  // Add class for turn indicator styling
                logEntry.innerHTML = `<span style="color: #00ffff;">🔄 ${message}</span>`;
            } else {
                logEntry.innerHTML = `<span style="color: #ff4444;">⚠️ ${message}</span>`;
            }
            
            log.appendChild(logEntry);
            scrollToBottom();
        }

        // Update Main Carrot AI
        function mainCarrotAI() {
            const mainCarrot = document.getElementById('AngryCarrot');
            if (!mainCarrot || mainCarrot.style.display === 'none') {
                activeEnemies--;
                logEnemyAction('Main Angry Carrot is already defeated.');
                checkEndOfEnemyTurn();
                return;
            }

            if (isFirstTurn) {
                // Force Anger on first turn
                isFirstTurn = false;
                applyBuff('AngryCarrot', 'anger', 5, 'res/Angry_Carrot_Anger_Buff.jpeg', 
                    'Deals triple damage for 5 turns');
                logAction('Angry Carrot', 'Anger', 'self', 'damage tripled for 5 turns');
            } else {
                // Regular AI behavior for subsequent turns
                const random = Math.random();

                if (random < 0.65) { // 65% chance - Carrot Cannon
                    const baseDamage = 500;
                    const multiplier = buffs['AngryCarrot'] && buffs['AngryCarrot']['anger'] ? 3 : 1;
                    const finalDamage = baseDamage * multiplier;

                    updateCharacterStatus('FarmerChamCham', finalDamage);
                    logAction('Angry Carrot', 'Carrot Cannon', 'Farmer Cham Cham', 
                        `deals ${finalDamage} damage${multiplier > 1 ? ' (Anger boosted)' : ''}`);
                }
                else if (random < 0.75) { // 10% chance - Anger
                    applyBuff('AngryCarrot', 'anger', 5, 'res/Angry_Carrot_Anger_Buff.jpeg', 
                        'Deals triple damage for 5 turns');
                    logAction('Angry Carrot', 'Anger', 'self', 'damage tripled for 5 turns');
                }
                else if (random < 0.85) { // 10% chance - Dormant
                    const healAmount = 2250; // Updated heal amount
                    healCharacter('AngryCarrot', healAmount);
                    applyBuff('AngryCarrot', 'dormant', 2, 'res/Angry_Carrot_Dormant_Buff.jpeg', 
                        'Heals 2250 HP and skips turn for 2 turns');
                    logAction('Angry Carrot', 'Dormant', 'self', 
                        `heals for ${healAmount} HP and becomes dormant for 2 turns`);
                }
                else { // 15% chance - Carrot Bomb
                    const baseDamage = 500;
                    const multiplier = buffs['AngryCarrot'] && buffs['AngryCarrot']['anger'] ? 3 : 1;
                    let finalDamage = baseDamage * multiplier;
                    
                    // Apply vulnerability multiplier if buff exists
                    if (buffs['FarmerChamCham'] && buffs['FarmerChamCham']['increasedDamage']) {
                        finalDamage = Math.floor(finalDamage * 1.25); // 25% more damage
                    }

                    updateCharacterStatus('FarmerChamCham', finalDamage);
                    healCharacter('AngryCarrot', finalDamage);
                    logAction('Angry Carrot', 'Carrot Bomb', 'Farmer Cham Cham', 
                        `deals ${finalDamage} damage and heals for ${finalDamage}${multiplier > 1 ? ' (Anger boosted)' : ''}${buffs['FarmerChamCham']['increasedDamage'] ? ' (Vulnerability bonus)' : ''}`);
                }
            }

            activeEnemies--;
            checkEndOfEnemyTurn();
        }

        // Update Weaker Carrot AI
        function weakerCarrotAI(carrotIndex) {
            const carrotId = `WeakerCarrot${carrotIndex}`;
            const carrot = document.getElementById(carrotId);

            if (!carrot || carrot.style.display === 'none') {
                activeEnemies--;
                logEnemyAction(`Weaker Angry Carrot ${carrotIndex} is already defeated.`);
                checkEndOfEnemyTurn();
                return;
            }

            const random = Math.random();

            if (random < 0.75) { // 75% chance - Carrot Cannon
                const baseDamage = 200;
                const multiplier = buffs[carrotId] && buffs[carrotId]['anger'] ? 1.4 : 1;
                let finalDamage = baseDamage * multiplier;
                
                // Apply vulnerability multiplier if buff exists
                if (buffs['FarmerChamCham'] && buffs['FarmerChamCham']['increasedDamage']) {
                    finalDamage = Math.floor(finalDamage * 1.25); // 25% more damage
                }

                updateCharacterStatus('FarmerChamCham', finalDamage);
                logAction(`Weaker Angry Carrot ${carrotIndex}`, 'Carrot Cannon', 'Farmer Cham Cham', 
                    `deals ${finalDamage} damage${multiplier > 1 ? ' (Anger boosted)' : ''}${buffs['FarmerChamCham']['increasedDamage'] ? ' (Vulnerability bonus)' : ''}`);
            }
            else if (random < 0.85) { // 10% chance - Anger
                applyBuff(carrotId, 'anger', 5, 'res/Angry_Carrot_Anger_Buff.jpeg', 
                    'Deals 40% more damage for 5 turns');
                logAction(`Weaker Angry Carrot ${carrotIndex}`, 'Anger', 'self', 
                    'damage increased by 40% for 5 turns');
            }
            else if (random < 0.90) { // 5% chance - Dormant
                const healAmount = 1000;
                healCharacter(carrotId, healAmount);
                applyBuff(carrotId, 'dormant', 2, 'res/Angry_Carrot_Dormant_Buff.jpeg', 
                    'Heals 1000 HP and skips turn for 2 turns');
                logAction(`Weaker Angry Carrot ${carrotIndex}`, 'Dormant', 'self', 
                    `heals for ${healAmount} HP and becomes dormant for 2 turns`);
            }
            else { // 10% chance - Carrot Bomb
                const baseDamage = 300;
                const multiplier = buffs[carrotId] && buffs[carrotId]['anger'] ? 1.4 : 1;
                let finalDamage = baseDamage * multiplier;
                
                // Apply vulnerability multiplier if buff exists
                if (buffs['FarmerChamCham'] && buffs['FarmerChamCham']['increasedDamage']) {
                    finalDamage = Math.floor(finalDamage * 1.25); // 25% more damage
                }

                updateCharacterStatus('FarmerChamCham', finalDamage);
                healCharacter(carrotId, finalDamage);
                logAction(`Weaker Angry Carrot ${carrotIndex}`, 'Carrot Bomb', 'Farmer Cham Cham', 
                    `deals ${finalDamage} damage and heals for ${finalDamage}${multiplier > 1 ? ' (Anger boosted)' : ''}${buffs['FarmerChamCham']['increasedDamage'] ? ' (Vulnerability bonus)' : ''}`);
            }

            activeEnemies--;
            checkEndOfEnemyTurn();
        }

        function castCarrotCannon() {
            let damage = 500;
            if (buffs['AngryCarrot'] && buffs['AngryCarrot']['tripleDamage'] > 0) {
                damage *= 3;
            }
            updateCharacterStatus('FarmerChamCham', damage);
            logAction('Angry Carrot', 'Carrot Cannon', 'Farmer Cham Cham', `deals ${damage} damage`);
        }

        function castAnger() {
            applyBuff('AngryCarrot', 'tripleDamage', 5, 'res/Angry_Carrot_Anger_Buff.jpeg', 'Triples damage for 5 turns');
            logAction('Angry Carrot', 'Anger', 'self', 'triples its damage for 5 turns');
        }

        function castDormant() {
            healCharacter('AngryCarrot', 1550);
            applyBuff('AngryCarrot', 'dormant', 2, 'res/Angry_Carrot_Dormant_Buff.jpeg', 'Heals 1550 HP and skips turn for 2 turns');
            logAction('Angry Carrot', 'Dormant', 'self', 'heals 1550 HP and skips turn');
        }

        function castCarrotBomb() {
            let damage = 400;
            if (buffs['AngryCarrot'] && buffs['AngryCarrot']['tripleDamage'] > 0) {
                damage *= 3;
            }
            updateCharacterStatus('FarmerChamCham', damage);
            healCharacter('AngryCarrot', damage);
            logAction('Angry Carrot', 'Carrot Bomb', 'Farmer Cham Cham', `deals ${damage} damage and heals for ${damage}`);
        }

        function applyBuff(targetId, buffType, duration, buffImage, description) {
            if (!buffs[targetId]) {
                buffs[targetId] = {};
            }
            
            // Add or update the buff
            buffs[targetId][buffType] = {
                value: 0.4, // Example value, adjust as needed
                duration: duration
            };
            
            // Add or update buff icon
            const buffContainer = document.getElementById(`${targetId}-buff-container`);
            if (buffContainer) {
                // Remove existing buff icon of the same type if it exists
                const existingBuff = buffContainer.querySelector(`[data-buff="${buffType}"]`);
                if (existingBuff) {
                    existingBuff.remove();
                }

                const buffIcon = document.createElement('div');
                buffIcon.className = 'buff-icon';
                buffIcon.dataset.buff = buffType;
                buffIcon.title = description;
                
                buffIcon.innerHTML = `
                    <img src="${buffImage}" alt="${buffType}">
                    <div class="buff-duration">${duration}</div>
                `;
                
                buffContainer.appendChild(buffIcon);
            }
        }

        // Function to get or create buff container
        function getBuffContainer(character) {
            const containerId = `${character}-buff-container`;
            let container = document.getElementById(containerId);
            
            if (!container) {
                console.warn(`Buff container not found for ${character}`);
                return null;
            }
            
            return container;
        }

        // Function to handle buff updates for a specific character
        function updateCharacterBuffs(character) {
            const container = document.getElementById(`${character}-buff-container`);
            if (!container) {
                console.warn(`Buff container not found for ${character}`);
                return false;
            }

            let hasDormantBuff = false;

            // Skip if no buffs exist for this character
            if (!buffs[character]) return false;

            Object.keys(buffs[character]).forEach(buffType => {
                buffs[character][buffType].duration--;

                if (buffs[character][buffType].duration <= 0) {
                    // Remove expired buff
                    const buffIcon = container.querySelector(`[data-buff="${buffType}"]`);
                    if (buffIcon) {
                        buffIcon.remove();
                    }

                    delete buffs[character][buffType];
                    logAction(character, 'Buff', buffType, '✨ has expired');
                } else {
                    // Check for dormant buff
                    if (buffType === 'dormant') {
                        hasDormantBuff = true;
                    }

                    // Update duration display
                    const buffIcon = container.querySelector(`[data-buff="${buffType}"]`);
                    if (buffIcon) {
                        const durationElement = buffIcon.querySelector('.buff-duration');
                        if (durationElement) {
                            durationElement.textContent = buffs[character][buffType].duration;
                        }
                    }
                }
            });

            return hasDormantBuff;
        }

        // Update the updateBuffs function to properly handle buff durations
        function updateBuffs() {
            // Update buffs for each character
            Object.keys(buffs).forEach(character => {
                const container = document.getElementById(`${character}-buff-container`);
                if (!container) {
                    console.warn(`Buff container not found for ${character}`);
                    return;
                }

                // Skip if no buffs exist for this character
                if (!buffs[character]) return;

                // Create a list of buffs to remove after iteration
                const buffsToRemove = [];

                Object.keys(buffs[character]).forEach(buffType => {
                    buffs[character][buffType].duration--;

                    if (buffs[character][buffType].duration <= 0) {
                        // Mark buff for removal
                        buffsToRemove.push(buffType);
                        
                        // Remove buff icon
                        const buffIcon = container.querySelector(`[data-buff="${buffType}"]`);
                        if (buffIcon) {
                            buffIcon.remove();
                        }
                        
                        logAction(character, 'Buff', buffType, '✨ has expired');
                    } else {
                        // Update duration display
                        const buffIcon = container.querySelector(`[data-buff="${buffType}"]`);
                        if (buffIcon) {
                            const durationElement = buffIcon.querySelector('.buff-duration');
                            if (durationElement) {
                                durationElement.textContent = buffs[character][buffType].duration;
                            }
                        }
                    }
                });

                // Remove expired buffs
                buffsToRemove.forEach(buffType => {
                    delete buffs[character][buffType];
                });
            });
        }
    

        function enableAbilities() {
            const abilities = document.querySelectorAll('.ability img');
            abilities.forEach(ability => {
                if (abilityCooldowns[ability.id] && abilityCooldowns[ability.id].current > 0) {
                    ability.style.pointerEvents = 'none';
                    ability.classList.add('disabled');
                } else {
                    ability.style.pointerEvents = 'auto';
                    ability.classList.remove('disabled');
                }
            });
        }

        function disableAbilities() {
            const abilities = document.querySelectorAll('.ability img');
            abilities.forEach(ability => {
                ability.style.pointerEvents = 'none';
                ability.classList.add('disabled');
            });
        }

        function healCharacter(character, baseHealAmount) {
            let healAmount = baseHealAmount;

            // Check for healing amplifier buff
            if (buffs[character] && buffs[character]['healing_amplifier']) {
                const amplifier = buffs[character]['healing_amplifier'].value;
                healAmount *= (1 + amplifier); // Apply the healing bonus
            }

            // Check for increased damage buff from Leap
            if (buffs[character] && buffs[character]['increasedDamage']) {
                const leapBonus = 0.15; // 15% additional healing from Leap
                healAmount *= (1 + leapBonus);
            }

            const statusElement = document.getElementById(`${character}-status`);
            const hpBarElement = document.getElementById(`${character}-hp-bar`);

            if (!statusElement || !hpBarElement) {
                console.error(`Element not found for character: ${character}`);
                return;
            }

            let currentHp = parseInt(statusElement.innerText.split('/')[0].split(': ')[1]);
            const maxHp = parseInt(statusElement.innerText.split('/')[1]);

            currentHp += Math.floor(healAmount);
            if (currentHp > maxHp) currentHp = maxHp;

            statusElement.innerText = `HP: ${currentHp}/${maxHp}`;

            const hpPercentage = (currentHp / maxHp) * 100;
            hpBarElement.style.width = `${hpPercentage}%`;

            // Log the healing action
            const log = document.getElementById('log');
            const logEntry = document.createElement('p');
            const healLog = document.createElement('p');
            healLog.innerHTML = `<span style="color: yellow;">💚 Healing:</span> <span style="color: green;">${character} healed for ${Math.floor(healAmount)} HP!</span>`;
            log.appendChild(healLog);
            scrollToBottom();
        }

        function logAction(actor, action, target, description) {
            const log = document.getElementById('log');
            const logEntry = document.createElement('p');
            
            // Define emojis for different actions
            const actionEmojis = {
                'Scratch': '🐱',
                'Leap': '⬆️',
                'Catboomerang': '🌀',
                'Wild Strike': '⚔️',
                'Carrot Cannon': '💥',
                'Anger': '😠',
                'Dormant': '💤',
                'Carrot Bomb': '💣',
                'Buff': '✨',
                'default': '➡️'
            };

            const emoji = actionEmojis[action] || actionEmojis.default;
            logEntry.innerHTML = `<span style="color: yellow;">${actor} ${emoji} ${action} on ${target}:</span> <span style="color: red;">${description}</span>`;
            log.appendChild(logEntry);
            scrollToBottom();
        }

        function scrollToBottom() {
            const log = document.getElementById('log');
            log.scrollTop = log.scrollHeight;
        }

        function useCatboomerang(targetId) {
            if (!isPlayerTurn) return;

            disableAbilities();
            startCooldown('ChamChamAbility3');

            const boomerang = document.getElementById('boomerang');
            boomerang.style.display = 'block';
            boomerang.style.left = '43%';
            boomerang.style.bottom = '150px';
            boomerang.classList.add('boomerang-throw');

            // First hit using current Scratch damage
            setTimeout(() => {
                boomerang.classList.remove('boomerang-throw');
                boomerang.style.transform = 'translate(0, -600px) rotate(360deg)';
                let damage = chamChamScratchDamage;
                updateCharacterStatus(targetId, damage);
                logAction('Farmer Cham Cham', 'Catboomerang', targetId, `deals ${damage} damage`);

                // Calculate healing with modifiers
                const healAmount = calculateHealingWithModifiers(damage, 'FarmerChamCham');
                if (healAmount > damage) {
                    healCharacter('FarmerChamCham', healAmount);
                }

                // Check if target is still alive
                if (targetId === 'AngryCarrot') {
                    checkCarrotHealth();
                } else {
                    checkWeakCarrotHealth(parseInt(targetId.replace('WeakerCarrot', '')));
                }

                const targetElement = document.getElementById(`${targetId}-status`);
                const currentHp = targetElement ? parseInt(targetElement.innerText.split('/')[0].split(': ')[1]) : 0;
                const additionalHit = Math.random() < 0.5 && currentHp > 0;

                if (additionalHit) {
                    // Second hit
                    setTimeout(() => {
                        boomerang.classList.add('boomerang-return');
                        setTimeout(() => {
                            updateCharacterStatus(targetId, damage);
                            logAction('Farmer Cham Cham', 'Catboomerang', targetId, `deals additional ${damage} damage`);

                            // Recalculate healing for the second hit
                            const healAmountSecond = calculateHealingWithModifiers(damage, 'FarmerChamCham');
                            if (healAmountSecond > damage) {
                                healCharacter('FarmerChamCham', healAmountSecond);
                            }

                            // Check if target is still alive after second hit
                            if (targetId === 'AngryCarrot') {
                                checkCarrotHealth();
                            } else {
                                checkWeakCarrotHealth(parseInt(targetId.replace('WeakerCarrot', '')));
                            }

                            boomerang.style.display = 'none';
                            isPlayerTurn = false;
                            setTimeout(carrotTurn, 1000);
                            chamChamScratchDamage += 50;
                            updateDamageBonus();
                        }, 1000);
                    }, 1000);
                } else {
                    // No second hit
                    if (currentHp <= 0) {
                        logAction('Farmer Cham Cham', 'Catboomerang', targetId, 'target died, additional hit skipped');
                    } else {
                        logAction('Farmer Cham Cham', 'Catboomerang', targetId, 'missed additional hit');
                    }
                    boomerang.style.display = 'none';
                    isPlayerTurn = false;
                    setTimeout(carrotTurn, 1000);
                }
            }, 1000);

            // Double-check abilities after the action
            setTimeout(doubleCheckAbilities, 1500);
        }

        function checkAllCarrotsDefeated() {
            const aliveCarrots = Array.from(document.querySelectorAll('.weaker-carrot')).filter(carrot => {
                const statusElement = carrot.querySelector('.status');
                const currentHp = parseInt(statusElement.innerText.split('/')[0].split(': ')[1]);
                return currentHp > 0;
            });

            if (aliveCarrots.length === 0) {
                isPlayerTurn = true;
                enableAbilities();
                const log = document.getElementById('log');
                const logEntry = document.createElement('p');
                logEntry.innerHTML = `<span style="color: yellow;">⚡ Event:</span> <span style="color: #00ff00;">🏆 Victory! All carrots have been defeated!</span>`;
                log.appendChild(logEntry);
                scrollToBottom();
            }
        }

        // Update useLeap to not trigger enemy turn
        function useLeap() {
            if (!isPlayerTurn || abilityCooldowns['ChamChamAbility2'].current > 0) return;

            disableAbilities();
            startCooldown('ChamChamAbility2');

            // Apply the increased damage and healing buff
            applyBuff('FarmerChamCham', 'increasedDamage', 3, 'res/Cham_A2.jpeg', 'Takes 25% more damage, heals 115% of damage dealt for 3 turns');
            logAction('Farmer Cham Cham', '⬆️ Leap', 'self', 'takes 25% more damage, heals 115% of damage dealt for 3 turns');

            // Don't trigger enemy turn
            enableAbilities();
        }

        function useWildStrike(targetId) {
            if (!isPlayerTurn) return;

            disableAbilities();
            let dropsGiven = false;  // Flag to track if drops have been given

            const numberOfHits = 4;
            for (let i = 0; i < numberOfHits; i++) {
                let damage = chamChamScratchDamage;
                
                // For the last hit, we'll handle drops normally
                if (i === numberOfHits - 1) {
                    updateCharacterStatus(targetId, damage);
                } else {
                    // For all other hits, we'll prevent drops
                    const currentElement = document.getElementById(targetId);
                    if (currentElement && currentElement.style.display !== 'none') {
                        // Temporarily store the handleDrops function
                        const originalHandleDrops = window.handleDrops;
                        window.handleDrops = () => {};  // Replace with empty function
                        
                        updateCharacterStatus(targetId, damage);
                        
                        // Restore the original handleDrops function
                        window.handleDrops = originalHandleDrops;
                    }
                }

                logAction('Farmer Cham Cham', '⚔️ Wild Strike', targetId, `hit ${i + 1}: deals ${damage} damage`);

                // Calculate healing with modifiers for each hit
                const healAmount = calculateHealingWithModifiers(damage, 'FarmerChamCham');
                if (healAmount > damage) {
                    healCharacter('FarmerChamCham', healAmount);
                }

                chamChamScratchDamage += 50;
                updateDamageBonus();
            }

            lastUsedAbility = 'WildStrike';
            isPlayerTurn = false;
            setTimeout(carrotTurn, 2000);
        }

        function updateCooldowns() {
            for (const abilityId in abilityCooldowns) {
                if (abilityCooldowns[abilityId].current > 0) {
                    abilityCooldowns[abilityId].current--;
                    
                    // Update cooldown display
                    const cooldownElement = document.getElementById(`${abilityId}Cooldown`);
                    if (cooldownElement) {
                        if (abilityCooldowns[abilityId].current > 0) {
                            cooldownElement.style.display = 'block';
                            cooldownElement.textContent = abilityCooldowns[abilityId].current;
                            document.getElementById(abilityId).classList.add('disabled');
                        } else {
                            cooldownElement.style.display = 'none';
                            document.getElementById(abilityId).classList.remove('disabled');
                        }
                    }
                }
            }
        }

        function startCooldown(abilityId) {
            if (abilityCooldowns[abilityId]) {
                abilityCooldowns[abilityId].current = abilityCooldowns[abilityId].max;
                const cooldownElement = document.getElementById(`${abilityId}Cooldown`);
                if (cooldownElement) {
                    cooldownElement.style.display = 'block';
                    cooldownElement.textContent = abilityCooldowns[abilityId].current;
                    document.getElementById(abilityId).classList.add('disabled');
                }
            }
        }

        // Update the checkCarrotHealth function to position the carrots properly
        function checkCarrotHealth() {
            const carrotElement = document.getElementById('AngryCarrot-status');
            if (!carrotElement) return;

            const carrotHp = parseInt(carrotElement.innerText.split('/')[0].split(': ')[1]);

            if (carrotHp <= 0 && !weakerCarrotsSpawned) {  // Add check for weakerCarrotsSpawned
                // Mark as spawned immediately to prevent multiple spawns
                weakerCarrotsSpawned = true;
                
                handleDrops('AngryCarrot', 'AngryCarrot');

                // Remove the main carrot with fade out
                const mainCarrot = document.getElementById('AngryCarrot');
                mainCarrot.style.animation = 'fadeOut 0.5s ease-in forwards';
                setTimeout(() => {
                    mainCarrot.style.display = 'none';
                    logAction('Angry Carrot', 'Defeated', 'self', 'has been defeated');
                    
                    // Spawn 3 weaker Angry Carrots
                    spawnWeakerAngryCarrots();
                    
                    // Decrement activeEnemies and check turn
                    activeEnemies--;
                    checkEndOfEnemyTurn();
                }, 500);
            }
        }

        function createWeakerCarrot(index) {
            const weakerCarrot = document.createElement('div');
            weakerCarrot.id = `WeakerCarrot${index}`;
            weakerCarrot.className = 'enemy weaker-carrot';
            
            weakerCarrot.innerHTML = `
                <img src="res/Angry_Carrot.jpeg" alt="Weaker Angry Carrot ${index}">
                <div class="buff-container" id="WeakerCarrot${index}-buff-container"></div>
                <div class="status">
                    <div class="hp-bar-container">
                        <div class="hp-bar" id="WeakerCarrot${index}-hp-bar" style="width: 100%"></div>
                    </div>
                    <div id="WeakerCarrot${index}-status">HP: 4250/4250</div>
                </div>
            `;
            
            // Add click handler for enemy info
            weakerCarrot.querySelector('img').addEventListener('click', function() {
                showEnemyInfo(`WeakerCarrot${index}`);
            });
            
            document.getElementById('WeakerCarrotsContainer').appendChild(weakerCarrot);
        }

        function showTargetingIcons() {
            // Remove any existing targeting icons
            const existingContainer = document.getElementById('targeting-container');
            if (existingContainer) {
                existingContainer.remove();
            }

            // Create targeting container
            const container = document.createElement('div');
            container.id = 'targeting-container';
            
            // Check which carrots are alive and create their targeting icons
            if (document.getElementById('AngryCarrot').style.display !== 'none') {
                // Main carrot is alive
                const targetIcon = createTargetIcon('AngryCarrot');
                container.appendChild(targetIcon);
            } else {
                // Check weaker carrots
                for (let i = 1; i <= 3; i++) {
                    const carrot = document.getElementById(`WeakerCarrot${i}`);
                    if (carrot && carrot.style.display !== 'none') {
                        const targetIcon = createTargetIcon(`WeakerCarrot${i}`);
                        container.appendChild(targetIcon);
                    }
                }
            }

            // Append to Cham Cham's image container instead of the character div
            const chamChamImageContainer = document.querySelector('#FarmerChamCham');
            chamChamImageContainer.appendChild(container);
        }

        function createTargetIcon(targetId) {
            const icon = document.createElement('img');
            icon.src = 'res/Angry_Carrot_Icon.png';
            icon.className = 'target-icon';
            icon.dataset.targetId = targetId;
            
            icon.addEventListener('click', () => {
                if (selectedAbility && targetingActive) {
                    executeAbility(selectedAbility, targetId);
                    hideTargetingIcons();
                    selectedAbility = null;
                    targetingActive = false;
                }
            });

            return icon;
        }

        function hideTargetingIcons() {
            const container = document.getElementById('targeting-container');
            if (container) {
                container.remove();
            }
        }
        

        function executeAbility(abilityId, targetId) {
            switch(abilityId) {
                case 'ChamChamAbility1':
                    useScratch(targetId);
                    break;
                case 'ChamChamAbility3':
                    useCatboomerang(targetId);
                    startCooldown('ChamChamAbility3');
                    break;
                case 'ChamChamAbility4':
                    useWildStrike(targetId);
                    startCooldown('ChamChamAbility4');
                    break;
            }
        }

        document.getElementById('start-button').addEventListener('click', startGame);
        document.getElementById('ChamChamAbility1').addEventListener('click', function() {
            if (!isPlayerTurn || abilityCooldowns['ChamChamAbility1'].current > 0) return;
            selectedAbility = 'ChamChamAbility1';
            targetingActive = true;
            showTargetingIcons();
        });
        document.getElementById('ChamChamAbility2').addEventListener('click', function() {
            if (!isPlayerTurn || abilityCooldowns['ChamChamAbility2'].current > 0) return;
            useLeap();
            startCooldown('ChamChamAbility2');
        });
        document.getElementById('ChamChamAbility3').addEventListener('click', function() {
            if (!isPlayerTurn || abilityCooldowns['ChamChamAbility3'].current > 0) return;
            selectedAbility = 'ChamChamAbility3';
            targetingActive = true;
            showTargetingIcons();
        });
        document.getElementById('ChamChamAbility4').addEventListener('click', function() {
            if (!isPlayerTurn || abilityCooldowns['ChamChamAbility4'].current >0) return;
            selectedAbility = 'ChamChamAbility4';
            targetingActive = true;
            showTargetingIcons();
        });
        document.getElementById('ChamChamAbility2').addEventListener('click', useLeap);

        document.getElementById('volume-slider').addEventListener('input', function(e) {
            if (bgAudio) {
                const volume = e.target.value / 100;
                bgAudio.volume = volume;
                bgAudio.muted = volume === 0;
            }
        });

        document.querySelector('#AngryCarrot img').addEventListener('click', function() {
            showEnemyInfo('AngryCarrot');
        });

        function showEnemyInfo(carrotId) {
            const infoWindow = document.getElementById('enemy-info');
            const isWeakerCarrot = carrotId.includes('WeakerCarrot');
            
            if (isWeakerCarrot) {
                infoWindow.querySelector('.enemy-info-content').innerHTML = `
                    <span class="close-button">&times;</span>
                    <h2>Weaker Angry Carrot Abilities</h2>
                    <div class="ability-info">
                        <h3>Carrot Cannon (75% chance)</h3>
                        <p>Deals 200 damage. If Anger buff is active, deals 40% more damage.</p>
                    </div>
                    <div class="ability-info">
                        <h3>Anger (10% chance)</h3>
                        <p>Applies a buff that increases all damage by 40% for 5 turns.</p>
                    </div>
                    <div class="ability-info">
                        <h3>Dormant (5% chance)</h3>
                        <p>Heals 1000 HP and skips turns for 2 turns.</p>
                    </div>
                    <div class="ability-info">
                        <h3>Carrot Bomb (10% chance)</h3>
                        <p>Deals 300 damage and heals for the same amount. If Anger buff is active, deals and heals for 40% more.</p>
                    </div>
                `;
            } else {
                infoWindow.querySelector('.enemy-info-content').innerHTML = `
                    <span class="close-button">&times;</span>
                    <h2>Angry Carrot Abilities</h2>
                    <div class="ability-info">
                        <h3>Carrot Cannon (65% chance)</h3>
                        <p>Deals 500 damage. If Anger buff is active, deals triple damage.</p>
                    </div>
                    <div class="ability-info">
                        <h3>Anger (10% chance)</h3>
                        <p>Applies a buff that triples all damage for 5 turns.</p>
                    </div>
                    <div class="ability-info">
                        <h3>Dormant (10% chance)</h3>
                        <p>Heals 2250 HP and skips turns for 2 turns.</p>
                    </div>
                    <div class="ability-info">
                        <h3>Carrot Bomb (15% chance)</h3>
                        <p>Deals 500 damage and heals for the same amount. If Anger buff is active, deals and heals for triple damage.</p>
                    </div>
                `;
            }

            // Add click handler for close button
            infoWindow.querySelector('.close-button').addEventListener('click', function() {
                infoWindow.style.display = 'none';
            });

            // Show the window
            infoWindow.style.display = 'block';
        }

        // Initialize draggable functionality
        document.addEventListener('DOMContentLoaded', function() {
            const infoWindow = document.getElementById('enemy-info');
            makeDraggable(infoWindow);
            
            // Remove the click-outside-to-close functionality
            // as it's no longer needed with the new window behavior
        });

        // Add drag functionality
        function makeDraggable(element) {
            let pos1 = 0, pos2 = 0, pos3 = 0, pos4 = 0;
            const content = element.querySelector('.enemy-info-content');
            
            if (content) {
                content.onmousedown = dragMouseDown;
            }

            function dragMouseDown(e) {
                e = e || window.event;
                e.preventDefault();
                // Get the mouse cursor position at startup
                pos3 = e.clientX;
                pos4 = e.clientY;
                document.onmouseup = closeDragElement;
                // Call a function whenever the cursor moves
                document.onmousemove = elementDrag;
            }

            function elementDrag(e) {
                e = e || window.event;
                e.preventDefault();
                // Calculate the new cursor position
                pos1 = pos3 - e.clientX;
                pos2 = pos4 - e.clientY;
                pos3 = e.clientX;
                pos4 = e.clientY;
                // Set the element's new position
                element.style.top = (element.offsetTop - pos2) + "px";
                element.style.left = (element.offsetLeft - pos1) + "px";
            }

            function closeDragElement() {
                // Stop moving when mouse button is released
                document.onmouseup = null;
                document.onmousemove = null;
            }
        }

        // Add cleanup function for when leaving the page
        window.addEventListener('beforeunload', function() {
            if (bgAudio) {
                bgAudio.pause();
                bgAudio = null;
            }
        });

        // Add this event listener for F6 and NUM5 keys
        document.addEventListener('keydown', function(event) {
            if (event.key === 'F6') {
                // Set Angry Carrot HP to 5
                const statusElement = document.getElementById('AngryCarrot-status');
                const hpBarElement = document.getElementById('AngryCarrot-hp-bar');
                
                if (statusElement && hpBarElement) {
                    const maxHp = parseInt(statusElement.innerText.split('/')[1]);
                    statusElement.innerText = `HP: 5/${maxHp}`;
                    
                    const hpPercentage = (5 / maxHp) * 100;
                    hpBarElement.style.width = `${hpPercentage}%`;
                    
                    // Log the debug action
                    const log = document.getElementById('log');
                    const logEntry = document.createElement('p');
                    logEntry.innerHTML = `<span style="color: yellow;">🔍 Debug:</span> <span style="color: orange;">Set Angry Carrot HP to 5</span>`;
                    log.appendChild(logEntry);
                    scrollToBottom();
                }
            } else if (event.key === 'NumPad5' || event.key === '5') {
                // Debug: Set all weaker carrots to 1 HP
                for (let i = 1; i <= 3; i++) {
                    const statusElement = document.getElementById(`WeakerCarrot${i}-status`);
                    const hpBarElement = document.getElementById(`WeakerCarrot${i}-hp-bar`);
                    
                    if (statusElement && hpBarElement) {
                        const maxHp = parseInt(statusElement.innerText.split('/')[1]);
                        statusElement.innerText = `HP: 1/${maxHp}`;
                        
                        const hpPercentage = (1 / maxHp) * 100;
                        hpBarElement.style.width = `${hpPercentage}%`;
                        
                        // Log the debug action
                        const log = document.getElementById('log');
                        const logEntry = document.createElement('p');
                        logEntry.innerHTML = `<span style="color: yellow;">🔍 Debug:</span> <span style="color: #ff0000;">Set Weaker Carrot ${i} HP to 1</span>`;
                        log.appendChild(logEntry);
                    }
                }
                scrollToBottom();
            }
        });

        function addItemToInventory(item, forceCount = false) {
            console.log(`Adding item ${item.id} with count ${item.count}`);
            
            // Get the item template from ITEM_DATABASE
            const itemTemplate = ITEM_DATABASE[item.id];
            if (!itemTemplate) {
                console.error('Item template not found:', item.id);
                return;
            }
            
            // Find existing stack of same item
            const existingSlot = inventory.slots.findIndex(slot => 
                slot && slot.id === item.id
            );
            
            if (existingSlot !== -1) {
                // Add to existing stack
                inventory.slots[existingSlot].count += forceCount ? item.count : 1;
                console.log(`Added to existing stack in slot ${existingSlot}, new count: ${inventory.slots[existingSlot].count}`);
            } else {
                // Find empty slot
                const emptySlot = inventory.slots.findIndex(slot => slot === null);
                if (emptySlot !== -1) {
                    inventory.slots[emptySlot] = {
                        id: item.id,
                        name: item.name,
                        image: item.image,
                        count: forceCount ? item.count : 1,
                        description: item.description,
                        usable: itemTemplate.usable, // Copy usable property from template
                        rarity: item.rarity,
                        cooldown: itemTemplate.cooldown // Also copy cooldown if it exists
                    };
                    console.log(`Created new stack in slot ${emptySlot} with count: ${inventory.slots[emptySlot].count}`);
                } else {
                    console.log('Inventory full!');
                }
            }
            
            updateInventoryDisplay();
        }

        function updateInventoryDisplay() {
            console.log('Updating inventory display');
            console.log('Current inventory slots:', inventory.slots);
            
            const slots = document.querySelectorAll('.inventory-slot');
            slots.forEach((slot, index) => {
                const item = inventory.slots[index];
                if (item) {
                    console.log(`Updating slot ${index} with item:`, item);
                    
                    // Clear existing content
                    slot.innerHTML = '';
                    
                    // Add item image
                    const img = document.createElement('img');
                    img.src = item.image;
                    img.alt = item.name;
                    slot.appendChild(img);
                    
                    // Add count if more than 1
                    if (item.count > 1) {
                        const countDiv = document.createElement('div');
                        countDiv.className = 'item-count';
                        countDiv.textContent = item.count;
                        slot.appendChild(countDiv);
                    }
                    
                    // Add cooldown overlay if on cooldown
                    const itemTemplate = ITEM_DATABASE[item.id];
                    if (itemTemplate && itemTemplate.cooldown && itemCooldowns[item.id] > 0) {
                        const overlay = document.createElement('div');
                        overlay.className = 'cooldown-overlay';
                        
                        const cooldownText = document.createElement('div');
                        cooldownText.className = 'cooldown-text';
                        cooldownText.textContent = itemCooldowns[item.id];
                        
                        overlay.appendChild(cooldownText);
                        slot.appendChild(overlay);
                        
                        // Add disabled class
                        slot.classList.add('disabled');
                    } else {
                        slot.classList.remove('disabled');
                    }
                    
                    // Add tooltip
                    slot.setAttribute('data-tooltip', `${item.name}\n${item.description}`);
                    
                    // Add click handler for usable items
                    if (item.usable) {
                        slot.onclick = function() {
                            const itemTemplate = ITEM_DATABASE[item.id];
                            if (itemTemplate && itemTemplate.cooldown && itemCooldowns[item.id] > 0) {
                                // Item is on cooldown
                                const log = document.getElementById('log');
                                const logEntry = document.createElement('p');
                                logEntry.innerHTML = `<span style="color: yellow;">⚠️ Cooldown:</span> <span style="color: #ff0000;">${item.name} is on cooldown for ${itemCooldowns[item.id]} turns</span>`;
                                log.appendChild(logEntry);
                                scrollToBottom();
                                return;
                            }
                            
                            if (!isUsingItem) {
                                isUsingItem = true;
                                showItemTargeting(item, index);
                            }
                        };
                    }
                } else {
                    // Clear empty slots
                    slot.innerHTML = '';
                    slot.removeAttribute('data-tooltip');
                    slot.onclick = null;
                }
            });
        }

        function showItemTargeting(item, slotIndex) {
            console.log('Showing targeting for:', item); // Debug log
            
            // Remove any existing targeting icons
            const existingContainer = document.getElementById('item-targeting-container');
            if (existingContainer) {
                existingContainer.remove();
            }

            // Create targeting container
            const container = document.createElement('div');
            container.id = 'item-targeting-container';
            
            // Create Cham Cham target icon
            const targetIcon = document.createElement('img');
            targetIcon.src = 'res/Cham_Cham_Target_Icon.png';
            targetIcon.className = 'target-icon';
            
            targetIcon.addEventListener('click', () => {
                useItem(item, slotIndex, 'FarmerChamCham'); // Updated to pass correct parameters
                container.remove();
                isUsingItem = false;
            });

            container.appendChild(targetIcon);
            
            // Append to the inventory
            document.querySelector('.inventory').appendChild(container);
        }

        async function useItem(item, slotIndex, targetId) {
            console.log('Using item:', item, 'on target:', targetId);
            
            if (!item || !item.usable) return;

            const itemTemplate = ITEM_DATABASE[item.id];
            if (!itemTemplate) {
                console.error('Item template not found:', item.id);
                return;
            }

            const user = auth.currentUser;
            if (!user) {
                console.error('No user logged in');
                return;
            }

            try {
                // Get the stack count before using the item
                const stackCount = item.count;
                console.log('Using item with stack count:', stackCount);
                
                // Use the effect from the item template
                const effect = await itemTemplate.effect(targetId, stackCount);
                
                if (effect) {
                    const log = document.getElementById('log');
                    const logEntry = document.createElement('p');

                    switch(effect.type) {
                        case 'currency':
                            logEntry.innerHTML = `<span style="color: yellow;">🎁 Currency:</span> <span style="color: #ffd700;">Added ${effect.value} ${effect.currencyType}</span>`;
                            // Remove the entire stack immediately for currency items
                            inventory.slots[slotIndex] = null;
                            await dbUpdate(dbRef(db, `users/${user.uid}/RaidInventory/items`), {
                                [item.id]: 0
                            });
                            break;
                        case 'heal':
                            healCharacter(effect.target, effect.value);
                            logEntry.innerHTML = `<span style="color: yellow;">💚 Item:</span> <span style="color: #00ff00;">Used ${item.name} to restore ${effect.value} HP</span>`;
                            await handleSingleUseItem(item, slotIndex);
                            break;
                        case 'buff':
                            logEntry.innerHTML = `<span style="color: yellow;">✨ Item:</span> <span style="color: #00ffff;">Applied ${item.name} buff</span>`;
                            await handleSingleUseItem(item, slotIndex);
                            break;
                        case 'skin':
                            logEntry.innerHTML = `<span style="color: yellow;">🎨 Skin:</span> <span style="color: #ffd700;">${effect.message}</span>`;
                            inventory.slots[slotIndex] = null;
                            await dbUpdate(dbRef(db, `users/${user.uid}/RaidInventory/items`), {
                                [item.id]: 0
                            });
                            break;
                        case 'duplicate_skin':
                            logEntry.innerHTML = `<span style="color: yellow;">💰 Duplicate Skin:</span> <span style="color: #ffd700;">${effect.message}</span>`;
                            inventory.slots[slotIndex] = null;
                            await dbUpdate(dbRef(db, `users/${user.uid}/RaidInventory/items`), {
                                [item.id]: 0
                            });
                            break;
                        case 'error':
                            logEntry.innerHTML = `<span style="color: yellow;">⚠️ Error:</span> <span style="color: #ff0000;">${effect.message}</span>`;
                            break;
                    }

                    log.appendChild(logEntry);
                    scrollToBottom();

                    // Apply cooldown if item has one
                    if (itemTemplate.cooldown) {
                        itemCooldowns[item.id] = itemTemplate.cooldown;
                    }

                    // Update the display
                    updateInventoryDisplay();
                }
            } catch (error) {
                console.error('Error using item:', error);
                const log = document.getElementById('log');
                const logEntry = document.createElement('p');
                logEntry.innerHTML = `<span style="color: yellow;">⚠️ Error:</span> <span style="color: #ff0000;">Failed to use ${item.name}</span>`;
                log.appendChild(logEntry);
                scrollToBottom();
            }
        }

        // Helper function for single-use items
        async function handleSingleUseItem(item, slotIndex) {
            const user = auth.currentUser;
            if (!user) return;

            const newCount = item.count - 1;
            if (newCount <= 0) {
                inventory.slots[slotIndex] = null;
                await dbUpdate(dbRef(db, `users/${user.uid}/RaidInventory/items`), {
                    [item.id]: 0
                });
            } else {
                inventory.slots[slotIndex].count = newCount;
                await dbUpdate(dbRef(db, `users/${user.uid}/RaidInventory/items`), {
                    [item.id]: newCount
                });
            }
        }

        const STAGE_1_DROPS = {
            AngryCarrot: {
                drops: [
                    {
                        item: 'health_potion',
                        chance: 0.80, // 80%
                        count: 2
                    },
                    {
                        item: 'cm',
                        chance: 0.10, // 10%
                        count: 5000
                    },
                    {
                        item: 'fm',
                        chance: 0.05, // 5%
                        count: 100
                    },
                    {
                        item: 'farmer_fang_skin',
                        chance: 0.01, // 1%
                        count: 1
                    }
                ]
            },
            WeakAngryCarrot: {
                drops: [
                    {
                        item: 'health_potion',
                        chance: 0.90, // 90%
                        count: 2
                    },
                    {
                        item: 'julia_pendant',
                        chance: 0.09, // 9%
                        count: 1
                    },
                    {
                        item: 'farmer_fang_skin',
                        chance: 0.01, // 1%
                        count: 1
                    }
                ]
            }
        };

        function handleDrops(enemyType, enemyId) {
            // Check if this enemy has already dropped loot
            if (droppedLoot.has(enemyId)) {
                return;
            }
            
            // Mark this enemy as having dropped loot
            droppedLoot.add(enemyId);

            // Get the loot table from STAGE_1_DROPS
            const lootTable = STAGE_1_DROPS[enemyType];
            if (!lootTable || !lootTable.drops) return;

            // Calculate drops
            const drops = [];
            lootTable.drops.forEach(drop => {
                if (Math.random() < drop.chance) {
                    // Get item details from ITEM_DATABASE
                    const itemData = ITEM_DATABASE[drop.item];
                    drops.push({
                        id: drop.item,
                        name: itemData.name,
                        count: drop.count,
                        image: itemData.image,
                        description: itemData.description,
                        rarity: itemData.rarity
                    });
                }
            });

            if (drops.length === 0) return;

            // Create drop window
            const dropWindow = document.createElement('div');
            dropWindow.className = 'drop-window';
            dropWindow.innerHTML = `
                <h2 style="color: white; text-align: center; margin-bottom: 15px;">Drops</h2>
                <div class="drop-items"></div>
                <button class="collect-button">Collect All</button>
            `;

            // Style the drop window
            Object.assign(dropWindow.style, {
                position: 'fixed',
                top: '50%',
                left: '50%',
                transform: 'translate(-50%, -50%)',
                backgroundColor: 'rgba(0, 0, 0, 0.9)',
                padding: '20px',
                borderRadius: '10px',
                border: '2px solid gold',
                zIndex: '1000'
            });

            // Add items to the window
            const dropItems = dropWindow.querySelector('.drop-items');
            drops.forEach(item => {
                const itemElement = document.createElement('div');
                itemElement.className = `drop-item rarity-${item.rarity}`;
                itemElement.innerHTML = `
                    <img src="${item.image}" alt="${item.name}">
                    <div class="item-info">
                        <span class="item-name">${item.name}</span>
                        <span class="item-count">×${item.count}</span>
                    </div>
                `;
                dropItems.appendChild(itemElement);
            });

            // Style the collect button
            const collectButton = dropWindow.querySelector('.collect-button');
            Object.assign(collectButton.style, {
                marginTop: '15px',
                padding: '10px 20px',
                backgroundColor: '#4CAF50',
                color: 'white',
                border: 'none',
                borderRadius: '5px',
                cursor: 'pointer',
                width: '100%'
            });

            // Add collect button functionality
            collectButton.onclick = async () => {
                const user = auth.currentUser;
                if (!user) return;

                // Add items to inventory
                for (const drop of drops) {
                    try {
                        // Update database
                        const inventoryRef = dbRef(db, `users/${user.uid}/RaidInventory/items/${drop.id}`);
                        const snapshot = await dbGet(inventoryRef);
                        const currentCount = snapshot.exists() ? snapshot.val() : 0;
                        
                        await dbUpdate(dbRef(db, `users/${user.uid}/RaidInventory/items`), {
                            [drop.id]: currentCount + drop.count
                        });

                        // Update local inventory
                        const existingSlot = inventory.slots.findIndex(slot => 
                            slot && slot.id === drop.id
                        );

                        if (existingSlot !== -1) {
                            // Add to existing stack
                            inventory.slots[existingSlot].count += drop.count;
                            console.log(`Added ${drop.count} ${drop.name} to existing stack`);
                        } else {
                            // Create new stack
                            addItemToInventory({
                                ...drop,
                                count: drop.count
                            }, true);
                            console.log(`Created new stack for ${drop.count} ${drop.name}`);
                        }
                    } catch (error) {
                        console.error(`Error adding ${drop.name} to inventory:`, error);
                    }
                }

                updateInventoryDisplay();
                dropWindow.remove();
            };

            // Add to document
            document.body.appendChild(dropWindow);
        }

        // Update the checkWeakCarrotHealth function
        function checkWeakCarrotHealth(carrotNumber) {
            const carrotId = `WeakerCarrot${carrotNumber}`;
            const statusElement = document.getElementById(`${carrotId}-status`);
            if (!statusElement) return;

            const carrotHp = parseInt(statusElement.innerText.split('/')[0].split(': ')[1]);

            if (carrotHp <= 0) {
                handleDrops('WeakAngryCarrot', carrotId);

                // Remove the weaker carrot with fade out
                const carrot = document.getElementById(carrotId);
                carrot.style.animation = 'fadeOut 0.5s ease-in forwards';
                setTimeout(() => {
                    carrot.style.display = 'none';
                    logAction(`Weaker Angry Carrot ${carrotNumber}`, 'Defeated', 'self', 'has been defeated');
                    
                    // Decrement activeEnemies and check turn
                    activeEnemies--;
                    checkEndOfEnemyTurn();

                    // Mark carrot as dead in the global state
                    if (!window.deadCarrots) {
                        window.deadCarrots = new Set();
                    }
                    window.deadCarrots.add(carrotNumber);

                    // Check if all carrots are dead
                    if (window.deadCarrots.size === 3) {
                        const log = document.getElementById('log');
                        const logEntry = document.createElement('p');
                        logEntry.innerHTML = `<span style="color: yellow;">⚡ Event:</span> <span style="color: #00ff00;">🏆 Victory! All carrots have been defeated!</span>`;
                        log.appendChild(logEntry);
                        scrollToBottom();
                        
                        // Handle stage completion
                        handleStageCompletion();
                    }
                }, 500);
            }
        }

        // Update the enemy turn function
        function enemyTurn() {
            if (!isPlayerTurn) {
                let attacksCompleted = 0;
                
                // Track which carrots are alive for attacking
                const aliveCarrots = [];
                for (let i = 1; i <= 3; i++) {
                    if (!window.deadCarrots?.has(i)) {
                        const carrotElement = document.getElementById(`WeakerCarrot${i}`);
                        if (carrotElement && carrotElement.style.display !== 'none') {
                            aliveCarrots.push(i);
                        }
                    }
                }

                // If no carrots are alive, enable player turn immediately
                if (aliveCarrots.length === 0) {
                    isPlayerTurn = true;
                    enableAbilities();
                    return;
                }

                // Disable abilities during enemy attacks
                disableAbilities();

                // Execute attacks sequentially
                aliveCarrots.forEach((carrotNum, index) => {
                    setTimeout(() => {
                        weakCarrotAttack(carrotNum);
                        attacksCompleted++;
                        
                        // Enable player turn after last attack
                        if (attacksCompleted === aliveCarrots.length) {
                            setTimeout(() => {
                                isPlayerTurn = true;
                                enableAbilities();
                                
                                const log = document.getElementById('log');
                                const logEntry = document.createElement('p');
                                logEntry.innerHTML = `<span style="color: #00ff00;">👉 Your turn!</span>`;
                                log.appendChild(logEntry);
                                scrollToBottom();
                            }, 1000);
                        }
                    }, index * 1500); // Increased delay between attacks
                });
            }
        }

        function enableAbilities() {
            const abilities = document.querySelectorAll('.ability');
            abilities.forEach(ability => {
                const abilityImg = ability.querySelector('img');
                if (abilityImg && !abilityCooldowns[abilityImg.id]?.current > 0) {
                    ability.classList.remove('disabled');
                    ability.style.pointerEvents = 'auto';
                }
            });
        }

        function disableAbilities() {
            const abilities = document.querySelectorAll('.ability');
            abilities.forEach(ability => {
                ability.classList.add('disabled');
                ability.style.pointerEvents = 'none';
            });
        }

        // Make sure this function is called whenever a carrot takes damage
        function updateCharacterStatus(targetId, damage) {
            const statusElement = document.getElementById(`${targetId}-status`);
            const hpBarElement = document.getElementById(`${targetId}-hp-bar`);
            
            if (statusElement && hpBarElement) {
                const [currentHp, maxHp] = statusElement.innerText.split('/').map(hp => parseInt(hp.replace('HP: ', '')));
                const newHp = Math.max(0, currentHp - damage);
                
                statusElement.innerText = `HP: ${newHp}/${maxHp}`;
                const hpPercentage = (newHp / maxHp) * 100;
                hpBarElement.style.width = `${hpPercentage}%`;
                
                // Apply green flash effect
                applyGreenFlashEffect(targetId);
                
                // Check appropriate health based on which carrot took damage
                if (targetId === 'AngryCarrot') {
                    checkCarrotHealth();
                } else if (targetId.startsWith('WeakerCarrot')) {
                    const carrotNumber = targetId.replace('WeakerCarrot', '');
                    checkWeakCarrotHealth(carrotNumber);
                }
            }
        }

        function calculateHealingWithModifiers(baseHealAmount, character) {
            let healAmount = baseHealAmount;

            // Check for healing amplifier buff
            if (buffs[character] && buffs[character]['healing_amplifier']) {
                const amplifier = buffs[character]['healing_amplifier'].value;
                healAmount *= (1 + amplifier); // Apply the healing bonus
            }

            // Check for increased damage buff from Leap
            if (buffs[character] && buffs[character]['increasedDamage']) {
                const leapBonus = 0.15; // 15% additional healing from Leap
                healAmount *= (1 + leapBonus);
            }

            // Add more healing modifiers here as needed

            return healAmount;
        }

        function doubleCheckAbilities() {
            // Check if it's the player's turn and abilities should be enabled
            if (isPlayerTurn) {
                enableAbilities();
            } else {
                disableAbilities();
            }
        }

        function checkEndOfEnemyTurn() {
            console.log(`Active Enemies Remaining: ${activeEnemies}`);
            if (activeEnemies <= 0) {
                isPlayerTurn = true;
                decrementCooldowns(); // Add this line
                enableAbilities();
                logPlayerTurn();
            }
        }

        function spawnWeakerAngryCarrots() {
            for (let i = 1; i <= 3; i++) {
                createWeakerCarrot(i);
            }
        }

        // Add this function to update the damage bonus display
        function updateDamageBonus() {
            const bonusElement = document.getElementById('scratch-damage-bonus');
            const bonus = chamChamScratchDamage - 100; // Calculate bonus (current - base)
            bonusElement.textContent = `+${bonus}`;
            
            // Add and remove animation class
            bonusElement.classList.add('damage-update');
            setTimeout(() => {
                bonusElement.classList.remove('damage-update');
            }, 300);
        }

        // Update turn handling to decrease cooldowns
        function endTurn() {
            // Decrease item cooldowns
            for (const itemId in itemCooldowns) {
                if (itemCooldowns[itemId] > 0) {
                    itemCooldowns[itemId]--;
                }
            }
            updateInventoryDisplay();
            
            // ... rest of endTurn function ...
        }

        // Find the function that decrements ability cooldowns and add item cooldown handling
        function decrementCooldowns() {
            console.log("Decrementing cooldowns..."); // Debug log

            // Decrement ability cooldowns
            for (const abilityId in abilityCooldowns) {
                if (abilityCooldowns[abilityId].current > 0) {
                    abilityCooldowns[abilityId].current--;
                    console.log(`Ability ${abilityId} cooldown: ${abilityCooldowns[abilityId].current}`);
                    
                    // Update ability display
                    const abilityElement = document.getElementById(abilityId);
                    if (abilityElement) {
                        const cooldownOverlay = abilityElement.querySelector('.cooldown-overlay');
                        if (abilityCooldowns[abilityId].current > 0) {
                            if (!cooldownOverlay) {
                                const overlay = document.createElement('div');
                                overlay.className = 'cooldown-overlay';
                                overlay.textContent = abilityCooldowns[abilityId].current;
                                abilityElement.appendChild(overlay);
                            } else {
                                cooldownOverlay.textContent = abilityCooldowns[abilityId].current;
                            }
                            abilityElement.classList.add('disabled');
                        } else {
                            if (cooldownOverlay) cooldownOverlay.remove();
                            abilityElement.classList.remove('disabled');
                        }
                    }
                }
            }

            // Decrement item cooldowns
            for (const itemId in itemCooldowns) {
                if (itemCooldowns[itemId] > 0) {
                    itemCooldowns[itemId]--;
                    console.log(`Item ${itemId} cooldown: ${itemCooldowns[itemId]}`);
                }
            }

            // Update inventory display to reflect cooldown changes
            updateInventoryDisplay();
        }

        // Make sure these functions call decrementCooldowns
        function checkEndOfEnemyTurn() {
            console.log(`Active Enemies Remaining: ${activeEnemies}`);
            if (activeEnemies <= 0) {
                isPlayerTurn = true;
                decrementCooldowns();
                enableAbilities();
                logPlayerTurn();
            }
        }

        function endPlayerTurn() {
            isPlayerTurn = false;
            decrementCooldowns();
            disableAbilities();
            enemyTurn();
        }

        // Helper function to calculate damage with buffs
        function calculateDamageWithBuffs(baseDamage, targetId) {
            let finalDamage = baseDamage;
            
            // Check for damage amplification buffs
            if (buffs[targetId] && buffs[targetId]['damage_vulnerability']) {
                const amplifier = buffs[targetId]['damage_vulnerability'].value;
                finalDamage = Math.floor(finalDamage * (1 + amplifier));
                console.log(`Damage amplified by ${amplifier * 100}%: ${baseDamage} -> ${finalDamage}`);
            }
            
            return finalDamage;
        }

        // Update the damage application in enemy attacks
        function applyDamage(targetId, damage) {
            const finalDamage = calculateDamageWithBuffs(damage, targetId);
            const statusElement = document.getElementById(`${targetId}-status`);
            if (!statusElement) return;

            const [currentHp, maxHp] = statusElement.innerText.split('/').map(hp => parseInt(hp.split(': ')[1]));
            const newHp = Math.max(0, currentHp - finalDamage);
            
            statusElement.innerText = `HP: ${newHp}/${maxHp}`;
            updateHPBar(targetId, newHp, maxHp);

            // Log the damage with vulnerability indication if applicable
            const log = document.getElementById('log');
            const logEntry = document.createElement('p');
            if (finalDamage > damage) {
                logEntry.innerHTML = `<span style="color: yellow;">⚔️ Damage:</span> <span style="color: #ff0000;">${targetId} takes ${finalDamage} damage (Amplified by vulnerability)</span>`;
            } else {
                logEntry.innerHTML = `<span style="color: yellow;">⚔️ Damage:</span> <span style="color: #ff0000;">${targetId} takes ${finalDamage} damage</span>`;
            }
            log.appendChild(logEntry);
            scrollToBottom();

            return newHp;
        }

        // Make sure Ability 2 applies the vulnerability buff correctly
        function ability2(targetId = 'FarmerChamCham') {
            if (!isPlayerTurn) return;
            
            const ability = document.getElementById('ability2');
            if (ability.classList.contains('disabled')) return;
            
            if (!buffs[targetId]) {
                buffs[targetId] = {};
            }
            
            // Apply 25% damage vulnerability
            buffs[targetId]['damage_vulnerability'] = {
                value: 0.25,  // 25% increase
                duration: 2
            };
            
            // Apply the buff visually
            applyBuff(targetId, 'damage_vulnerability', 2, 'path/to/ability2/icon.png', 'Takes 25% more damage');
            
            // Set cooldown
            const cooldown = 4;
            abilityCooldowns['ability2'] = {
                max: cooldown,
                current: cooldown
            };
            
            updateCooldownDisplays();
            
            // Log the ability use
            const log = document.getElementById('log');
            const logEntry = document.createElement('p');
            logEntry.innerHTML = `<span style="color: yellow;">🎯 Ability:</span> <span style="color: #ff6b6b">Cham Cham becomes vulnerable, taking 25% more damage for 2 turns</span>`;
            log.appendChild(logEntry);
            scrollToBottom();
            
            endPlayerTurn();
        }

        // Update the carrot abilities
        const ANGRY_CARROT_ABILITIES = {
            carrotCannon: {
                name: 'Carrot Cannon',
                baseDamage: 500,
                execute: (targetId) => {
                    const finalDamage = calculateDamageWithBuffs(500, targetId);
                    applyDamage(targetId, finalDamage);
                    logAction('Angry Carrot', 'Carrot Cannon', targetId, `deals ${finalDamage} damage`);
                    applyRedFlashEffect(targetId);
                }
            }
        };

        const WEAKER_CARROT_ABILITIES = {
            basicAttack: {
                name: 'Basic Attack',
                baseDamage: 200,
                execute: (targetId, carrotNumber) => {
                    const finalDamage = calculateDamageWithBuffs(200, targetId);
                    applyDamage(targetId, finalDamage);
                    logAction(`Weaker Carrot ${carrotNumber}`, 'Basic Attack', targetId, `deals ${finalDamage} damage`);
                    applyRedFlashEffect(targetId);
                }
            }
        };

        // Update the attack functions to use these abilities
        function mainCarrotAttack() {
            if (!isPlayerTurn) {
                ANGRY_CARROT_ABILITIES.carrotCannon.execute('FarmerChamCham');
                checkEndOfEnemyTurn();
            }
        }

        function weakCarrotAttack(carrotNumber) {
            if (!isPlayerTurn) {
                WEAKER_CARROT_ABILITIES.basicAttack.execute('FarmerChamCham', carrotNumber);
                checkEndOfEnemyTurn();
            }
        }

        // Helper function to calculate damage with buffs
        function calculateDamageWithBuffs(baseDamage, targetId) {
            let finalDamage = baseDamage;
            
            // Check for damage vulnerability buff
            if (buffs[targetId] && buffs[targetId]['damage_vulnerability']) {
                const amplifier = buffs[targetId]['damage_vulnerability'].value;
                finalDamage = Math.floor(finalDamage * (1 + amplifier));
                console.log(`Damage amplified by ${amplifier * 100}%: ${baseDamage} -> ${finalDamage}`);
            }
            
            return finalDamage;
        }

        // Update the logAction function to handle damage messages better
        function logAction(source, action, target, message) {
            const log = document.getElementById('log');
            const logEntry = document.createElement('p');
            
            // Check if the message includes amplified damage
            const isAmplified = buffs[target] && buffs[target]['damage_vulnerability'];
            const damageMessage = isAmplified ? `${message} (Amplified by vulnerability)` : message;
            
            logEntry.innerHTML = `<span style="color: yellow;">💥 Attack:</span> <span style="color: #ff0000;">${source} uses ${action} on ${target}: ${damageMessage}</span>`;
            log.appendChild(logEntry);
            scrollToBottom();
        }

        // Add this function to handle stage completion
        async function handleStageCompletion() {
            // Disable all abilities
            disableAbilities();
            
            // Create the "Go to Stage Two" button
            const stageButton = document.createElement('button');
            stageButton.id = 'next-stage-button';
            stageButton.innerHTML = 'Go to Stage Two';
            stageButton.className = 'next-stage-button';
            
            // Style the button
            Object.assign(stageButton.style, {
                position: 'fixed',
                top: '30%',
                left: '50%',
                transform: 'translate(-50%, -50%)',
                padding: '20px 40px',
                fontSize: '24px',
                backgroundColor: '#4CAF50',
                color: 'white',
                border: 'none',
                borderRadius: '10px',
                cursor: 'pointer',
                boxShadow: '0 4px 8px rgba(0,0,0,0.2)',
                animation: 'fadeIn 0.5s ease-in'
            });

            // Add hover effect
            stageButton.onmouseover = () => {
                stageButton.style.backgroundColor = '#45a049';
            };
            stageButton.onmouseout = () => {
                stageButton.style.backgroundColor = '#4CAF50';
            };

            // Add click handler
            stageButton.onclick = async () => {
                // Save completion status to database
                const user = auth.currentUser;
                if (user) {
                    try {
                        await dbSet(dbRef(db, `users/${user.uid}/Raid/Farm/Stage1`), 1);
                        window.location.href = 'Stage_2_Farm.html';
                    } catch (error) {
                        console.error('Error saving completion status:', error);
                    }
                }
            };

            // Add button to the document
            document.body.appendChild(stageButton);

            // Add CSS animation
            const style = document.createElement('style');
            style.textContent = `
                @keyframes fadeIn {
                    from { opacity: 0; transform: translate(-50%, -50%) scale(0.9); }
                    to { opacity: 1; transform: translate(-50%, -50%) scale(1); }
                }
                .next-stage-button:hover {
                    transform: translate(-50%, -50%) scale(1.05);
                    transition: all 0.2s ease;
                }
            `;
            document.head.appendChild(style);
        }
    </script>
</body>
</html>