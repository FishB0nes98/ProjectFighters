<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Project Fighters - Champion Select</title>
    <link rel="icon" href="Icons/Profile/talim_desert.webp" type="image/webp">
    <script src="https://www.gstatic.com/firebasejs/9.10.0/firebase-app.js" type="module"></script>
    <script src="https://www.gstatic.com/firebasejs/9.10.0/firebase-auth.js" type="module"></script>
    <script src="https://www.gstatic.com/firebasejs/9.10.0/firebase-database.js" type="module"></script>
    <style>
        :root {
            --primary-color: #0A1428;
            --secondary-color: #1E2328;
            --accent-color: #C89B3C;
            --text-color: #F0E6D2;
            --border-color: #463714;
            --hover-color: #785A28;
            --mew-pink: #FF69B4;
            --mew-light-pink: #FFC0CB;
            --mew-blue: #87CEFA;
            --mew-green: #98FB98;
            --mew-yellow: #FFFF99;
            --mew-purple: #DDA0DD;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', sans-serif;
        }

        body {
            background-color: var(--primary-color);
            color: var(--text-color);
            height: 100vh;
            display: grid;
            grid-template-columns: 300px 1fr 300px;
            grid-template-rows: 60px 1fr 180px; /* Increased the footer row height */
            gap: 10px;
            padding: 10px;
            /* position: relative; - Removed */
        }

        /* Background image styles - REMOVED */
        /* .background-image { ... } */

        /* body::before overlay - REMOVED */
        /* body::before { ... } */

        /* Header Section */
        .header {
            grid-column: 1 / -1;
            background-color: var(--secondary-color);
            border: 1px solid var(--border-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0 20px;
        }

        .timer {
            font-size: 24px;
            color: var(--accent-color);
        }

        .phase-info {
            text-align: center;
        }

        /* Add banned champions display styles */
        .banned-champions {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .banned-champion-portrait {
            width: 40px;
            height: 40px;
            border: 2px solid var(--border-color);
            border-radius: 4px;
            position: relative;
            overflow: hidden;
        }

        .banned-champion-portrait img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .banned-champion-portrait.empty {
            background-color: var(--primary-color);
        }

        .banned-champion-portrait::after {
            content: '×';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 30px;
            color: #ff0000;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        }

        /* Remove role selector styles */
        .role-selector {
            display: none;
        }

        /* Left Sidebar */
        .left-sidebar {
            background-color: var(--secondary-color);
            border: 1px solid var(--border-color);
            display: flex;
            flex-direction: column;
            gap: 15px;
            padding: 15px;
            overflow-y: auto;
            border-radius: 8px;
        }

        .team-member {
            display: flex;
            align-items: center;
            gap: 15px;
            padding: 20px;
            background-color: var(--primary-color);
            border-radius: 8px;
            position: relative;
            min-height: 120px;
            margin-bottom: 15px;
            transition: all 0.3s ease;
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
        }

        .team-member.picking {
            border: 2px solid var(--accent-color);
            animation: glowPulse 2s infinite;
            transform: scale(1.02);
            background-color: rgba(200, 155, 60, 0.1);
        }

        @keyframes pulse {
            0% {
                box-shadow: 0 0 0 0 rgba(200, 155, 60, 0.4);
            }
            70% {
                box-shadow: 0 0 0 10px rgba(200, 155, 60, 0);
            }
            100% {
                box-shadow: 0 0 0 0 rgba(200, 155, 60, 0);
            }
        }

        @keyframes glowPulse {
            0% {
                box-shadow: 0 0 5px var(--accent-color);
            }
            50% {
                box-shadow: 0 0 20px var(--accent-color), 0 0 30px var(--accent-color);
            }
            100% {
                box-shadow: 0 0 5px var(--accent-color);
            }
        }

        .champion-portrait {
            width: 80px;
            height: 80px;
            border-radius: 12px;
            background-color: var(--border-color);
            overflow: hidden;
            border: 2px solid var(--border-color);
            transition: all 0.3s ease;
            flex-shrink: 0;
        }

        .team-member.picking .champion-portrait {
            border-color: var(--accent-color);
            transform: scale(1.05);
        }

        .champion-portrait img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .player-info {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 5px;
            padding-right: 10px;
        }

        .player-name {
            font-weight: bold;
            color: var(--text-color);
            font-size: 1.1em;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
        }

        .player-rank {
            font-size: 0.9em;
            color: var(--accent-color);
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
        }

        .player-role {
            font-size: 0.9em;
            color: var(--text-color);
            opacity: 0.8;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
        }

        .pick-order-indicator {
            display: none;
        }

        .team-member::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(to right, rgba(0, 0, 0, 0.8), rgba(0, 0, 0, 0.6));
            border-radius: 8px;
            z-index: 0;
        }

        .team-member > * {
            position: relative;
            z-index: 2;
        }

        .player-slot {
            border: 2px solid var(--accent-color) !important;
            box-shadow: 0 0 20px var(--accent-color);
        }

        /* Main Content */
        .main-content {
            display: grid;
            grid-template-rows: auto 1fr;
            gap: 10px;
            max-height: calc(100vh - 180px); /* Adjust for header and footer */
            overflow: hidden;
            position: relative; /* Needed for overlay */
            border-radius: 8px; /* Optional: rounds corners */
            background-image: url('Event/Tokyo Mew Mew Event 2.png');
            background-size: cover;
            background-position: center;
            z-index: 0; /* Ensure it's behind content */
        }

        /* Add overlay for main content background */
        .main-content::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(10, 20, 40, 0.85); /* Adjust opacity as needed */
            z-index: 1; /* Overlay is above the background image */
            border-radius: 8px; /* Match parent */
            pointer-events: none; /* Allow clicks through overlay */
        }

        /* Ensure content inside main-content is above the overlay */
        .main-content > * {
            position: relative;
            z-index: 2;
        }

        .champion-search {
            display: flex;
            gap: 10px;
            padding: 10px;
            background-color: transparent; /* Make transparent */
            /* border: 1px solid var(--border-color); - Optionally remove border */
            position: sticky;
            top: 0;
            z-index: 10;
        }

        .search-input {
            flex: 1;
            padding: 8px;
            background-color: var(--primary-color);
            border: 1px solid var(--border-color);
            color: var(--text-color);
            border-radius: 4px;
        }

        .champion-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
            gap: 10px;
            padding: 15px;
            background-color: transparent; /* Make transparent */
            /* border: 1px solid var(--border-color); - Optionally remove border */
            overflow-y: auto;
            max-height: 100%;
            align-content: start;
        }

        .champion-card {
            position: relative;
            aspect-ratio: 1;
            cursor: pointer;
            transition: transform 0.2s;
            width: 100px;
            height: 100px;
            opacity: 0.5;
        }

        .champion-card.available {
            opacity: 1;
        }

        .champion-card.picked {
            pointer-events: none;
            opacity: 0.3;
        }

        .champion-card:hover {
            transform: scale(1.1);
            z-index: 1;
        }

        .champion-card img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            border: 2px solid var(--border-color);
            border-radius: 4px;
        }

        /* Add winrate and tier display styles */
        .champion-meta {
            position: absolute;
            top: 0;
            right: 0;
            background: rgba(0, 0, 0, 0.7);
            color: var(--text-color);
            padding: 2px 4px;
            font-size: 10px;
            border-radius: 0 4px 0 4px;
            display: flex;
            align-items: center;
            gap: 2px;
        }

        .champion-tier {
            font-weight: bold;
        }

        .tier-sp {
            color: #FF9900; /* Gold/orange for S+ tier */
        }

        .tier-s {
            color: #FF5588; /* Pink/red for S tier */
        }

        .tier-a {
            color: #AA99FF; /* Purple for A tier */
        }

        .tier-b {
            color: #77CCFF; /* Light blue for B tier */
        }

        .tier-c {
            color: #77DD77; /* Green for C tier */
        }

        .tier-d {
            color: #AAAAAA; /* Gray for D tier */
        }

        /* Add custom scrollbar */
        .champion-grid::-webkit-scrollbar {
            width: 8px;
        }

        .champion-grid::-webkit-scrollbar-track {
            background: var(--primary-color);
            border-radius: 4px;
        }

        .champion-grid::-webkit-scrollbar-thumb {
            background: var(--accent-color);
            border-radius: 4px;
        }

        .champion-grid::-webkit-scrollbar-thumb:hover {
            background: var(--hover-color);
        }

        /* Right Sidebar */
        .right-sidebar {
            background-color: var(--secondary-color);
            border: 1px solid var(--border-color);
            display: flex;
            flex-direction: column;
            gap: 15px;
            padding: 15px;
            overflow-y: auto;
            border-radius: 8px;
        }

        .champion-splash {
            width: 100%;
            height: 200px;
            background-color: var(--primary-color);
            border: 1px solid var(--border-color);
            margin-bottom: 10px;
        }

        .summoner-spells {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
        }

        .spell-slot {
            width: 40px;
            height: 40px;
            background-color: var(--primary-color);
            border: 1px solid var(--border-color);
            border-radius: 4px;
        }

        /* Footer */
        .footer {
            grid-column: 1 / -1;
            background-color: var(--secondary-color);
            border: 1px solid var(--border-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px 20px;
            gap: 15px;
            height: 100%; /* Take full height of grid row */
        }

        .chat-section {
            flex: 0 1 500px;
            height: 150px; /* Increased height */
            background-color: var(--primary-color);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        /* Volume Control Styles */
        .volume-control-container {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: var(--secondary-color);
            padding: 10px;
            border-radius: 8px;
            border: 1px solid var(--border-color);
            display: flex;
            align-items: center;
            gap: 10px;
            z-index: 1001;
        }

        .play-music-button {
            background: none;
            border: none;
            color: var(--text-color);
            cursor: pointer;
            padding: 5px;
            display: none;
            transition: color 0.3s ease;
        }

        .play-music-button:hover {
            color: var(--accent-color);
        }

        .play-music-button.show {
            display: block;
        }

        .volume-slider {
            -webkit-appearance: none;
            width: 100px;
            height: 4px;
            border-radius: 2px;
            background: var(--primary-color);
            outline: none;
        }

        .volume-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: var(--accent-color);
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .volume-slider::-webkit-slider-thumb:hover {
            transform: scale(1.2);
            background: var(--hover-color);
        }

        .volume-icon {
            color: var(--text-color);
            cursor: pointer;
            transition: color 0.3s ease;
        }

        .volume-icon:hover {
            color: var(--accent-color);
        }

        .chat-messages {
            flex: 1;
            overflow-y: auto;
            padding: 8px;
            font-size: 14px;
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .chat-message {
            padding: 4px 8px;
            border-radius: 4px;
            background-color: var(--secondary-color);
            word-break: break-word;
            display: flex;
            flex-wrap: wrap;
            align-items: baseline;
            gap: 4px;
        }

        .chat-message .sender {
            color: var(--accent-color);
            font-weight: bold;
            margin-right: 6px;
            max-width: 200px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .chat-message .message-text {
            flex: 1;
            min-width: 0;
            word-wrap: break-word;
            overflow-wrap: break-word;
        }

        .chat-input {
            padding: 8px;
            background-color: var(--secondary-color);
            border: none;
            border-top: 1px solid var(--border-color);
            color: var(--text-color);
            font-size: 14px;
            width: 100%;
        }

        .chat-input:focus {
            outline: none;
            border-top: 1px solid var(--accent-color);
        }

        .footer-buttons {
            display: flex;
            gap: 10px;
        }

        .load-build-button {
            padding: 12px 24px;
            background: linear-gradient(to bottom right, var(--accent-color), #785A28);
            color: var(--text-color);
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 1px;
            transition: all 0.3s ease;
            position: relative;
            display: none;
        }

        .load-build-button.available {
            display: block;
            animation: pulse 2s infinite;
            background: linear-gradient(45deg, var(--accent-color), #D4AF37);
        }

        .load-build-button.available:hover {
            transform: translateY(-2px);
            animation: none;
            background: linear-gradient(45deg, #D4AF37, var(--accent-color));
        }

        .load-build-button.selected {
            animation: none;
            background: linear-gradient(45deg, #4CAF50, #45a049);
            box-shadow: 0 0 10px rgba(76, 175, 80, 0.5);
        }

        .copy-build {
            padding: 12px 24px;
            background: linear-gradient(to bottom right, var(--accent-color), #785A28);
            color: var(--text-color);
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 1px;
            transition: all 0.3s ease;
        }

        .copy-build:hover {
            transform: translateY(-2px);
            background: linear-gradient(to bottom right, #D4AF37, var(--accent-color));
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        }

        .rating-button {
            padding: 8px 16px;
            background: var(--primary-color);
            color: var(--text-color);
            border: 2px solid var(--accent-color);
            border-radius: 4px;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 8px;
            transition: all 0.3s ease;
        }

        .rating-button:hover {
            background: var(--accent-color);
        }

        .rating-button.liked {
            background: var(--accent-color);
            color: var(--text-color);
        }

        .build-actions {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 15px;
            gap: 10px;
        }

        /* Build selection modal */
        .build-selection-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .build-selection-content {
            background: var(--secondary-color);
            padding: 20px;
            border-radius: 10px;
            border: 1px solid var(--border-color);
            width: 90%;
            max-width: 1200px;
            max-height: 90vh;
            overflow-y: auto;
        }

        .build-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: 20px;
            padding: 20px;
        }

        .build-card {
            background: var(--primary-color);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 15px;
            cursor: pointer;
            transition: transform 0.2s;
        }

        .build-card:hover {
            transform: scale(1.02);
            border-color: var(--accent-color);
        }

        .build-title {
            font-size: 18px;
            color: var(--accent-color);
            margin-bottom: 10px;
        }

        .build-info {
            font-size: 14px;
            color: var(--text-color);
            margin-bottom: 10px;
        }

        .build-items {
            display: flex;
            gap: 5px;
            flex-wrap: wrap;
            margin-top: 10px;
        }

        .build-item {
            width: 40px;
            height: 40px;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            overflow: hidden;
        }

        .build-item img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        /* Role Selection */
        .role-selector {
            display: flex;
            gap: 5px;
            padding: 5px;
        }

        .role-icon {
            width: 30px;
            height: 30px;
            background-color: var(--primary-color);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            cursor: pointer;
            transition: border-color 0.2s;
        }

        .role-icon.selected {
            border-color: var(--accent-color);
        }

        /* Filters */
        .filter-section {
            display: flex;
            gap: 10px;
        }

        .filter-button {
            padding: 5px 10px;
            background-color: var(--primary-color);
            border: 1px solid var(--border-color);
            color: var(--text-color);
            border-radius: 4px;
            cursor: pointer;
        }

        .filter-button.active {
            background-color: var(--accent-color);
        }

        /* Add this to your existing styles */
        .role-select-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .role-select-content {
            background: var(--secondary-color);
            padding: 40px;
            border-radius: 10px;
            border: 1px solid var(--border-color);
            text-align: center;
            width: 600px;
        }

        .role-select-title {
            font-size: 28px;
            color: var(--accent-color);
            margin-bottom: 30px;
        }

        .role-buttons {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 15px;
        }

        .role-select-btn {
            padding: 20px;
            background: var(--primary-color);
            border: 2px solid var(--border-color);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            color: var(--text-color);
            font-size: 18px;
            font-weight: bold;
        }

        .role-select-btn:hover {
            background: var(--hover-color);
            transform: translateY(-2px);
            border-color: var(--accent-color);
        }

        .champion-card.unavailable {
            opacity: 0.3;
            cursor: not-allowed;
        }

        .champion-name {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: rgba(0, 0, 0, 0.7);
            color: var(--text-color);
            font-size: 12px;
            padding: 4px;
            text-align: center;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        /* Add these styles to your existing CSS */
        .skin-selection-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .skin-selection-content {
            background: var(--secondary-color);
            padding: 20px;
            border-radius: 10px;
            border: 1px solid var(--border-color);
            width: 90%;
            max-height: 90vh;
            overflow-y: auto;
        }

        .skin-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(320px, 1fr));
            gap: 20px;
            padding: 20px;
        }

        .skin-card {
            background: var(--primary-color);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            overflow: hidden;
            cursor: pointer;
            transition: transform 0.2s;
        }

        .skin-card:hover {
            transform: scale(1.05);
            border-color: var(--accent-color);
        }

        .skin-card img {
            width: 100%;
            /* Set height to maintain 16:9 aspect ratio */
            aspect-ratio: 16/9;
            object-fit: cover;
        }

        /* Add a new class for skin names in the skin selection modal */
        .skin-card-name {
            padding: 10px;
            text-align: center;
            color: var(--text-color);
            font-size: 14px;
            display: block;
            background-color: rgba(0, 0, 0, 0.7);
        }

        .skin-name {
            position: absolute;
            bottom: 10px;
            left: 10px;
            font-size: 14px;
            color: white;
            background-color: rgba(0, 0, 0, 0.7);
            padding: 3px 6px;
            border-radius: 4px;
            display: none !important; /* Hide it visually but keep the element */
            visibility: hidden !important;
            opacity: 0 !important;
            z-index: 10;
        }

        .team-member {
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
            position: relative;
            z-index: 1;
        }

        .team-member::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            border-radius: 5px;
            z-index: 0;
        }

        .team-member > * {
            position: relative;
            z-index: 2;
        }

        /* Adjust team member size to better show background */
        .team-member {
            min-height: 100px;
            margin-bottom: 10px;
            border-radius: 5px;
            padding: 15px;
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .skin-image {
            width: 100%;
            height: auto;
            aspect-ratio: 16/9;
            object-fit: cover;
            border-radius: 8px 8px 0 0;
        }

        /* Add these styles for the start match button */
        .start-match-button {
            padding: 12px 24px;
            background: linear-gradient(to bottom right, var(--accent-color), #785A28);
            color: var(--text-color);
            border: none;
            border-radius: 4px;
            cursor: not-allowed;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 1px;
            transition: all 0.3s ease;
            opacity: 0.5;
        }

        .start-match-button.ready {
            background: linear-gradient(45deg, #4CAF50, #45a049);
            cursor: pointer;
            opacity: 1;
            animation: pulse 2s infinite;
        }

        .start-match-button.ready:hover {
            transform: translateY(-2px);
            animation: none;
            background: linear-gradient(45deg, #45a049, #4CAF50);
            box-shadow: 0 0 20px rgba(76, 175, 80, 0.4);
        }

        /* Add ban modal styles */
        .ban-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .ban-modal-content {
            background: var(--secondary-color);
            padding: 20px;
            border-radius: 10px;
            border: 1px solid var(--border-color);
            width: 90%;
            max-width: 1200px;
            max-height: 90vh;
            overflow-y: auto;
        }

        .ban-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
            gap: 10px;
            padding: 15px;
        }

        .ban-card {
            position: relative;
            aspect-ratio: 1;
            cursor: pointer;
            transition: transform 0.2s;
            width: 100px;
            height: 100px;
        }

        .ban-card:hover {
            transform: scale(1.1);
        }

        .ban-card img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            border: 2px solid var(--border-color);
            border-radius: 4px;
        }

        /* Add ban-card meta info styles */
        .ban-card .champion-meta {
            position: absolute;
            top: 0;
            right: 0;
            background: rgba(0, 0, 0, 0.7);
            color: var(--text-color);
            padding: 2px 4px;
            font-size: 10px;
            border-radius: 0 4px 0 4px;
            display: flex;
            align-items: center;
            gap: 2px;
        }

        .ban-card .champion-name {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: rgba(0, 0, 0, 0.7);
            color: var(--text-color);
            font-size: 12px;
            padding: 4px;
            text-align: center;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .banned-champion {
            opacity: 0.5;
            pointer-events: none;
        }

        .banned-champion::after {
            content: '×';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 60px;
            color: #ff0000;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        }

        .ban-phase-info {
            text-align: center;
            margin-bottom: 20px;
            color: var(--accent-color);
            font-size: 24px;
        }

        .ban-portraits {
            display: flex;
            gap: 10px;
            margin: 10px 0;
            justify-content: center;
        }

        .ban-portrait {
            width: 50px;
            height: 50px;
            position: relative;
            border: 2px solid var(--border-color);
            border-radius: 4px;
            overflow: hidden;
        }

        .ban-portrait img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .ban-portrait.empty {
            background-color: var(--primary-color);
        }

        /* Add styles for the meta legend */
        .meta-legend {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(10, 20, 40, 0.9);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 10px;
            color: var(--text-color);
            font-size: 12px;
            z-index: 5;
            max-width: 180px;
        }

        .meta-legend h4 {
            color: var(--accent-color);
            margin-bottom: 8px;
            text-align: center;
        }

        .meta-legend .tier-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 4px;
        }

        .meta-legend .tier-name {
            font-weight: bold;
            margin-right: 10px;
        }

        /* Tokyo Mew Mew Transition Animation Styles */
        .mew-mew-transition {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background-color: rgba(255, 105, 180, 0.2);
            z-index: 9999;
            display: none;
            justify-content: center;
            align-items: center;
            overflow: hidden;
        }

        .mew-mew-transition.active {
            display: flex;
            animation: bg-fade 3s forwards;
        }

        @keyframes bg-fade {
            0% { background-color: rgba(255, 105, 180, 0.2); }
            50% { background-color: rgba(255, 105, 180, 0.6); }
            100% { background-color: rgba(255, 255, 255, 1); }
        }

        .sparkle-container {
            position: absolute;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        .sparkle {
            position: absolute;
            width: 15px;
            height: 15px;
            background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path fill="%23FF69B4" d="M12,1L9,9L1,12L9,15L12,23L15,15L23,12L15,9L12,1Z"/></svg>');
            background-size: contain;
            animation: sparkle-float 2s linear forwards;
            opacity: 0;
        }

        @keyframes sparkle-float {
            0% { transform: translate(0, 0) rotate(0deg) scale(0); opacity: 0; }
            10% { opacity: 1; }
            90% { opacity: 0.8; }
            100% { transform: translate(var(--tx), var(--ty)) rotate(360deg) scale(1.5); opacity: 0; }
        }

        .heart {
            position: absolute;
            width: 25px;
            height: 25px;
            background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path fill="%23FF69B4" d="M12,21.35L10.55,20.03C5.4,15.36 2,12.27 2,8.5C2,5.41 4.42,3 7.5,3C9.24,3 10.91,3.81 12,5.08C13.09,3.81 14.76,3 16.5,3C19.58,3 22,5.41 22,8.5C22,12.27 18.6,15.36 13.45,20.03L12,21.35Z"/></svg>');
            background-size: contain;
            animation: heart-float 2.5s linear forwards;
            opacity: 0;
        }

        @keyframes heart-float {
            0% { transform: translate(0, 0) scale(0); opacity: 0; }
            20% { opacity: 1; }
            100% { transform: translate(var(--tx), var(--ty)) scale(1.2); opacity: 0; }
        }

        .mew-logo {
            width: 300px;
            height: 300px;
            background-image: url('Event/Tokyo Mew Mew Logo.png');
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
            animation: pulse-grow 2.5s ease-in-out forwards;
            position: relative;
            z-index: 10;
            opacity: 0;
        }

        @keyframes pulse-grow {
            0% { transform: scale(0.5); opacity: 0; }
            40% { transform: scale(1.2); opacity: 1; }
            60% { transform: scale(1.1); opacity: 1; }
            80% { transform: scale(1.2); opacity: 0.8; }
            100% { transform: scale(2); opacity: 0; }
        }

        .ring {
            position: absolute;
            border: 4px solid var(--mew-pink);
            border-radius: 50%;
            animation: ring-expand 2s ease-out forwards;
            opacity: 0;
        }

        @keyframes ring-expand {
            0% { width: 0; height: 0; opacity: 0; }
            20% { opacity: 0.8; }
            100% { width: 600px; height: 600px; opacity: 0; }
        }

        .flash {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: white;
            z-index: 10000;
            opacity: 0;
            pointer-events: none;
            animation: flash-animation 3s ease-out forwards;
        }

        @keyframes flash-animation {
            0% { opacity: 0; }
            80% { opacity: 0; }
            85% { opacity: 0.9; }
            100% { opacity: 0; }
        }
    </style>
</head>
<body>
    <!-- Background Image - REMOVED -->
    <!-- <img src="Event/Tokyo Mew Mew Event 2.png" alt="Background" class="background-image"> -->
    
    <audio id="background-music" loop>
        Your browser does not support the audio element.
    </audio>

    <!-- Tokyo Mew Mew Transition -->
    <div class="mew-mew-transition" id="mewMewTransition">
        <div class="sparkle-container" id="sparkleContainer"></div>
        <div class="ring"></div>
        <div class="mew-logo"></div>
        <div class="flash"></div>
    </div>

    <!-- Add Volume Control -->
    <div class="volume-control-container">
        <button class="play-music-button" id="playMusicButton">
            <i class="fas fa-play"></i>
        </button>
        <i class="fas fa-volume-up volume-icon" id="volumeIcon"></i>
        <input type="range" class="volume-slider" id="volumeSlider" min="0" max="100" value="20">
    </div>

    <!-- Add this at the start of the body -->
    <div class="role-select-modal" id="roleSelectModal">
        <div class="role-select-content">
            <h2 class="role-select-title">Select Your Role</h2>
            <div class="role-buttons">
                <button class="role-select-btn" data-role="Top">Top</button>
                <button class="role-select-btn" data-role="Jungle">Jungle</button>
                <button class="role-select-btn" data-role="Mid">Mid</button>
                <button class="role-select-btn" data-role="Adc">ADC</button>
                <button class="role-select-btn" data-role="Support">Support</button>
            </div>
        </div>
    </div>

    <!-- Add this HTML after your role selection modal -->
    <div class="skin-selection-modal" id="skinSelectionModal">
        <div class="skin-selection-content">
            <h2 class="role-select-title">Select Your Skin</h2>
            <div class="skin-grid" id="skinGrid">
                <!-- Skins will be added here dynamically -->
            </div>
        </div>
    </div>

    <!-- Add this new modal -->
    <div class="build-selection-modal" id="buildSelectionModal">
        <div class="build-selection-content">
            <h2 class="role-select-title">Select Build</h2>
            <div class="build-grid" id="buildGrid">
                <!-- Builds will be added here dynamically -->
            </div>
        </div>
    </div>

    <!-- Add ban modal -->
    <div class="ban-modal" id="banModal">
        <div class="ban-modal-content">
            <div class="ban-phase-info">
                <h2>Ban Phase</h2>
                <p>Select a champion to ban</p>
            </div>
            <div class="ban-portraits">
                <div class="ban-portrait empty" id="blueBan"></div>
                <div class="ban-portrait empty" id="redBan"></div>
            </div>
            <div class="ban-grid" id="banGrid">
                <!-- Champions will be added here dynamically -->
            </div>
        </div>
    </div>

    <!-- Header -->
    <header class="header">
        <div class="timer">30</div>
        <div class="phase-info">
            <h2>CHAMPION SELECT</h2>
            <p>Pick Your Champion</p>
        </div>
        <div class="banned-champions">
            <div class="banned-champion-portrait empty" id="blueBanPortrait"></div>
            <div class="banned-champion-portrait empty" id="redBanPortrait"></div>
        </div>
    </header>

    <!-- Left Sidebar (Blue Team) -->
    <aside class="left-sidebar">
        <div class="team-member" id="blue-1">
            <div class="champion-portrait"></div>
            <div class="player-info">
                <div class="player-name">You</div>
                <div class="player-rank">0 RP</div>
            </div>
            <div class="pick-order-indicator"></div>
        </div>
        <div class="team-member" id="blue-2">
            <div class="champion-portrait"></div>
            <div class="player-info">
                <div class="player-name">AI Player 1</div>
                <div class="player-rank">0 RP</div>
            </div>
            <div class="pick-order-indicator"></div>
        </div>
        <div class="team-member" id="blue-3">
            <div class="champion-portrait"></div>
            <div class="player-info">
                <div class="player-name">AI Player 2</div>
                <div class="player-rank">0 RP</div>
            </div>
            <div class="pick-order-indicator"></div>
        </div>
        <div class="team-member" id="blue-4">
            <div class="champion-portrait"></div>
            <div class="player-info">
                <div class="player-name">AI Player 3</div>
                <div class="player-rank">0 RP</div>
            </div>
            <div class="pick-order-indicator"></div>
        </div>
        <div class="team-member" id="blue-5">
            <div class="champion-portrait"></div>
            <div class="player-info">
                <div class="player-name">AI Player 4</div>
                <div class="player-rank">0 RP</div>
            </div>
            <div class="pick-order-indicator"></div>
        </div>
    </aside>

    <!-- Main Content -->
    <main class="main-content">
        <div class="champion-search">
            <input type="text" class="search-input" placeholder="Search champions...">
            <div class="filter-section">
                <button class="filter-button active" data-role="all">All</button>
                <button class="filter-button" data-role="Top">Top</button>
                <button class="filter-button" data-role="Jungle">Jungle</button>
                <button class="filter-button" data-role="Mid">Mid</button>
                <button class="filter-button" data-role="Adc">ADC</button>
                <button class="filter-button" data-role="Support">Support</button>
            </div>
        </div>
        <div class="champion-grid">
            <!-- Champion cards will be dynamically added here -->
        </div>
    </main>

    <!-- Right Sidebar (Red Team) -->
    <aside class="right-sidebar">
        <div class="team-member" id="red-1">
            <div class="champion-portrait"></div>
            <div class="player-info">
                <div class="player-name">AI Player 5</div>
                <div class="player-rank">0 RP</div>
            </div>
            <div class="pick-order-indicator"></div>
        </div>
        <div class="team-member" id="red-2">
            <div class="champion-portrait"></div>
            <div class="player-info">
                <div class="player-name">AI Player 6</div>
                <div class="player-rank">0 RP</div>
            </div>
            <div class="pick-order-indicator"></div>
        </div>
        <div class="team-member" id="red-3">
            <div class="champion-portrait"></div>
            <div class="player-info">
                <div class="player-name">AI Player 7</div>
                <div class="player-rank">0 RP</div>
            </div>
            <div class="pick-order-indicator"></div>
        </div>
        <div class="team-member" id="red-4">
            <div class="champion-portrait"></div>
            <div class="player-info">
                <div class="player-name">AI Player 8</div>
                <div class="player-rank">0 RP</div>
            </div>
            <div class="pick-order-indicator"></div>
        </div>
        <div class="team-member" id="red-5">
            <div class="champion-portrait"></div>
            <div class="player-info">
                <div class="player-name">AI Player 9</div>
                <div class="player-rank">0 RP</div>
            </div>
            <div class="pick-order-indicator"></div>
        </div>
    </aside>

    <!-- Footer -->
    <footer class="footer">
        <div class="footer-buttons">
            <button class="start-match-button" disabled>START MATCH</button>
            <button class="load-build-button" id="loadBuildButton" style="display: none;">LOAD BUILD</button>
        </div>
        <div class="chat-section">
            <div class="chat-messages"></div>
            <input type="text" class="chat-input" placeholder="Type a message...">
        </div>
        <div class="settings">
            <!-- Settings buttons will go here -->
        </div>
    </footer>

    <script type="module">
        // Audio Control
        const audio = document.getElementById('background-music');
        const volumeSlider = document.getElementById('volumeSlider');
        const volumeIcon = document.getElementById('volumeIcon');
        const playMusicButton = document.getElementById('playMusicButton');
        let lastVolume = 0.2;

        // Set initial volume
        audio.volume = 0.2;

        // Determine music path based on patch
        const musicPath = CURRENT_PATCH === "2.5" ? "Songs/team_up_tokyo_mew_mew.mp3" : "res/music/ranked.mp3";
        audio.src = musicPath;

        // Try to play audio and handle autoplay restrictions
        async function initializeAudio() {
            try {
                await audio.play();
                playMusicButton.style.display = 'none';
            } catch (err) {
                console.log('Autoplay prevented:', err);
                playMusicButton.classList.add('show');
            }
        }

        // Initialize audio when the page loads
        initializeAudio();

        // Add click event for play button
        playMusicButton.addEventListener('click', async () => {
            try {
                await audio.play();
                playMusicButton.style.display = 'none';
            } catch (err) {
                console.error('Failed to play audio:', err);
            }
        });

        // Try to play audio when user interacts with the page
        document.addEventListener('click', async () => {
            if (audio.paused) {
                try {
                    await audio.play();
                    playMusicButton.style.display = 'none';
                } catch (err) {
                    console.log('Still cannot play audio:', err);
                }
            }
        }, { once: true });

        // Update volume when slider changes
        volumeSlider.addEventListener('input', (e) => {
            const volume = e.target.value / 100;
            audio.volume = volume;
            lastVolume = volume;
            updateVolumeIcon(volume);
        });

        // Toggle mute/unmute when clicking the icon
        volumeIcon.addEventListener('click', () => {
            if (audio.volume > 0) {
                audio.volume = 0;
                volumeSlider.value = 0;
            } else {
                audio.volume = lastVolume;
                volumeSlider.value = lastVolume * 100;
            }
            updateVolumeIcon(audio.volume);
        });

        // Update volume icon based on volume level
        function updateVolumeIcon(volume) {
            volumeIcon.className = 'fas volume-icon';
            if (volume === 0) {
                volumeIcon.className += ' fa-volume-mute';
            } else if (volume < 0.5) {
                volumeIcon.className += ' fa-volume-down';
            } else {
                volumeIcon.className += ' fa-volume-up';
            }
        }

        import { initializeApp } from 'https://www.gstatic.com/firebasejs/9.10.0/firebase-app.js';
        import { getAuth, onAuthStateChanged } from 'https://www.gstatic.com/firebasejs/9.10.0/firebase-auth.js';
        import { getDatabase, ref, set, get, update } from 'https://www.gstatic.com/firebasejs/9.10.0/firebase-database.js';
        import { roles } from './roles.js';
        import { usernames } from './usernames.js';
        import { chatMessages, contextualResponses, timeBasedMessages, roleMessages } from './chat_messages.js';
        import { CURRENT_PATCH } from './patch.js'; // Import CURRENT_PATCH

        // Firebase configuration
        const firebaseConfig = {
            apiKey: "AIzaSyCqhxq6sPDU3EmuvvkBIIDJ-H6PsBc42Jg",
            authDomain: "project-fighters-by-fishb0nes.firebaseapp.com",
            databaseURL: "https://project-fighters-by-fishb0nes-default-rtdb.europe-west1.firebasedatabase.app",
            projectId: "project-fighters-by-fishb0nes",
            storageBucket: "project-fighters-by-fishb0nes.appspot.com",
            messagingSenderId: "867339299995",
            appId: "1:867339299995:web:99c379940014b9c05cea3e",
            measurementId: "G-LNEM6HR842"
        };

        // Initialize Firebase
        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const database = getDatabase(app);

        // Add after Firebase initialization and before game state variables
        let queueId = Date.now().toString(36) + Math.random().toString(36).substr(2);
        console.log('Generated queue ID:', queueId);

        // Champion Select Timer
        let timeLeft = 30;
        const timerElement = document.querySelector('.timer');
        
        const timer = setInterval(() => {
            timeLeft--;
            timerElement.textContent = timeLeft;
            
            if (timeLeft <= 0) {
                clearInterval(timer);
                // Handle time out
            }
        }, 1000);

        // Role Selection
        const roleIcons = document.querySelectorAll('.role-icon');
        roleIcons.forEach(icon => {
            icon.addEventListener('click', () => {
                roleIcons.forEach(i => i.classList.remove('selected'));
                icon.classList.add('selected');
            });
        });

        // Add currentFilter variable to game state
        let currentFilter = 'all';
        let currentUser = null;

        // Update the champion search
        const searchInput = document.querySelector('.search-input');
        searchInput.addEventListener('input', (e) => {
            const searchTerm = e.target.value.toLowerCase();
            filterChampions(searchTerm, currentFilter);
        });

        // Update filter buttons
        const filterButtons = document.querySelectorAll('.filter-button');
        filterButtons.forEach(button => {
            button.addEventListener('click', () => {
                filterButtons.forEach(b => b.classList.remove('active'));
                button.classList.add('active');
                currentFilter = button.dataset.role;
                filterChampions(searchInput.value.toLowerCase(), currentFilter);
            });
        });

        // Add filter champions function
        function filterChampions(searchTerm, roleFilter) {
            const cards = document.querySelectorAll('.champion-card');
            cards.forEach(card => {
                const champion = card.title;
                const matchesSearch = champion.toLowerCase().includes(searchTerm);
                const matchesRole = roleFilter === 'all' || roles[roleFilter]?.includes(champion);
                
                if (matchesSearch && matchesRole) {
                    card.style.display = 'block';
                } else {
                    card.style.display = 'none';
                }
            });
        }

        // Chat Functionality
        const chatInput = document.querySelector('.chat-input');

        // Remove the old aiNames array and replace it with this line
        const shuffledUsernames = [...usernames].sort(() => Math.random() - 0.5);

        // Add this object to store AI player RP values
        let aiPlayerRankPoints = {};

        // Modify the onAuthStateChanged function to store AI RP values
        onAuthStateChanged(auth, async (user) => {
            if (user) {
                currentUser = user;
                // Get user data
                const userRef = ref(database, `users/${user.uid}`);
                const snapshot = await get(userRef);
                const userData = snapshot.val();

                let aiNameIndex = 0;

                // Get player's rank points for reference
                const playerRankPoints = userData['Rank points'] || 0;

                // Update all player names and ranks
                for (let team of ['blue', 'red']) {
                    for (let slot = 1; slot <= 5; slot++) {
                        const memberElement = document.getElementById(`${team}-${slot}`);
                        const nameElement = memberElement.querySelector('.player-name');
                        const rankElement = memberElement.querySelector('.player-rank');

                        if (team === playerTeam && slot === playerSlot) {
                            // This is the player's slot
                            nameElement.textContent = userData.username || user.email.split('@')[0];
                            rankElement.textContent = `${playerRankPoints} RP`;
                            memberElement.classList.add('player-slot');
                            console.log(`Player assigned to ${team} team, slot ${slot}`);
                        } else {
                            // AI players
                            nameElement.textContent = shuffledUsernames[aiNameIndex++];
                            
                            // Generate and store AI rank points only once
                            const aiKey = `${team}_${slot}`;
                            if (!aiPlayerRankPoints[aiKey]) {
                                let aiRankPoints;
                                if (Math.random() < 0.85) {
                                    // 85% chance to be close to player's rank (±200 RP)
                                    const variation = Math.floor(Math.random() * 401) - 200;
                                    aiRankPoints = Math.max(0, playerRankPoints + variation);
                                } else {
                                    // 15% chance to be significantly different (±500 to ±1000 RP)
                                    const isHigher = Math.random() < 0.5;
                                    const variation = Math.floor(Math.random() * 501) + 500;
                                    aiRankPoints = Math.max(0, playerRankPoints + (isHigher ? variation : -variation));
                                }
                                aiPlayerRankPoints[aiKey] = aiRankPoints;
                            }
                            
                            rankElement.textContent = `${aiPlayerRankPoints[aiKey]} RP`;
                        }
                    }
                }

                // Show role selection modal
                document.getElementById('roleSelectModal').style.display = 'flex';
            } else {
                window.location.href = 'index.html';
            }
        });

        // Game state
        let currentPickIndex = 0;
        let selectedRole = null;
        let pickOrder = [];
        let playerTeam = Math.random() < 0.5 ? 'blue' : 'red'; // Randomly assign player team
        let playerSlot = Math.floor(Math.random() * 5) + 1;
        let pickedChampions = new Set();
        let roleAssignments = {
            blue: { 1: '', 2: '', 3: '', 4: '', 5: '' },
            red: { 1: '', 2: '', 3: '', 4: '', 5: '' }
        };

        // Add skin selection state
        let selectedChampion = null;
        let availableSkins = [];
        let selectedBuild = null;

        // Add selectChampion function
        async function selectChampion(champion) {
            if (isPlayerTurn()) {
                selectedChampion = champion;
                await showSkinSelection(champion);
            } else {
                const currentPick = pickOrder[currentPickIndex];
                const memberElement = document.getElementById(`${currentPick.team}-${currentPick.slot}`);
                
                const portrait = memberElement.querySelector('.champion-portrait');
                portrait.innerHTML = `<img src="Icons/${champion}.png" alt="${champion}">`;
                
                pickedChampions.add(champion);
                checkAllChampionsSelected(); // Check after each pick
                
                currentPickIndex++;
                if (currentPickIndex < pickOrder.length) {
                    updateCurrentPick();
                    updateAvailableChampions();
                    
                    if (!isPlayerTurn()) {
                        setTimeout(makeAIPick, 1000);
                    }
                }
            }
        }

        // Add showSkinSelection function
        async function showSkinSelection(champion) {
            const modal = document.getElementById('skinSelectionModal');
            const skinGrid = document.getElementById('skinGrid');
            skinGrid.innerHTML = '';

            try {
                // Get user's owned skins from Firebase
                const userRef = ref(database, `users/${currentUser.uid}/skins`);
                const snapshot = await get(userRef);
                const ownedSkins = snapshot.val() || {};

                // Import skin data
                const { characters } = await import('./characterskinref.js');
                const { skinToBaseCharacterMap } = await import('./skinmapping.js');

                // Get available skins for the champion
                const availableSkins = characters[champion] || [];
                
                // Create skin cards for owned skins
                availableSkins.forEach(skin => {
                    if (ownedSkins[skin]) { // Only show owned skins
                        const card = document.createElement('div');
                        card.className = 'skin-card';
                        
                        const img = document.createElement('img');
                        img.src = `Skins/${skin}.webp`; // Try webp first
                        img.onerror = function() {
                            // If webp fails, try jpeg
                            this.src = `Skins/${skin}.jpeg`;
                            this.onerror = function() {
                                // If jpeg fails, try png
                                this.src = `Skins/${skin}.png`;
                                this.onerror = function() {
                                    // If png fails, try jpg
                                    this.src = `Skins/${skin}.jpg`;
                                    this.onerror = function() {
                                        // If jpg fails, try jfif
                                        this.src = `Skins/${skin}.jfif`;
                                        this.onerror = function() {
                                            // If all fail, use champion icon
                                            this.src = `Icons/${champion}.png`;
                                        }
                                    }
                                }
                            }
                        };
                        img.alt = skin;
                        img.className = 'skin-image';
                        
                        const name = document.createElement('div');
                        name.className = 'skin-card-name';
                        name.textContent = skin;
                        
                        card.appendChild(img);
                        card.appendChild(name);
                        
                        card.addEventListener('click', () => {
                            selectSkin(skin);
                            modal.style.display = 'none';
                        });
                        
                        skinGrid.appendChild(card);
                    }
                });

                // Only show modal if there are owned skins
                const hasOwnedSkins = Array.from(skinGrid.children).length > 0;
                if (hasOwnedSkins) {
                    modal.style.display = 'flex';
                } else {
                    // If no owned skins, just use the champion as is
                    selectSkin(champion);
                }
            } catch (error) {
                console.error('Error loading skins:', error);
                // Fallback to default selection if skin loading fails
                selectSkin(champion);
            }
        }

        // Update selectSkin function
        function selectSkin(skin) {
            console.log('Selecting skin:', skin);
            if (!queueId) {
                console.error('No queue ID available');
                return;
            }

            const currentPick = pickOrder[currentPickIndex];
            const memberElement = document.getElementById(`${currentPick.team}-${currentPick.slot}`);
            
            // Update portrait
            const portrait = memberElement.querySelector('.champion-portrait');
            portrait.innerHTML = `<img src="Icons/${selectedChampion}.png" alt="${selectedChampion}">`;
            
            // Create or get the skin-name element
            let skinNameElement = memberElement.querySelector('.skin-name');
            if (!skinNameElement) {
                skinNameElement = document.createElement('div');
                skinNameElement.className = 'skin-name';
                memberElement.appendChild(skinNameElement);
            }
            
            // Set the skin name immediately in the UI but don't display it
            skinNameElement.textContent = skin;
            console.log(`Set skin name for ${currentPick.team}-${currentPick.slot} to ${skin}`);
            
            // Try different image extensions for the skin
            const img = new Image();
            img.onload = function() {
                // Update background with successfully loaded skin image
                memberElement.style.backgroundImage = `url('${this.src}')`;
                memberElement.style.backgroundSize = 'cover';
                memberElement.style.backgroundPosition = 'center';
                
                // Force a repaint to ensure the background updates
                memberElement.style.display = 'none';
                memberElement.offsetHeight; // Trigger reflow
                memberElement.style.display = 'flex';

                // Show Load Build button after skin is selected with animation
                const loadBuildButton = document.getElementById('loadBuildButton');
                loadBuildButton.style.display = 'block';
                loadBuildButton.classList.add('available');

                // Update the queue data with the selected skin
                const queueRef = ref(database, `Queue/${queueId}/players/${currentPick.team}_${currentPick.slot}`);
                update(queueRef, {
                    skin: skin,
                    champion: selectedChampion
                }).then(() => {
                    console.log('Selected skin updated in queue data:', skin);
                    
                    // Update the skin name in the data but don't show it
                    const skinNameElement = memberElement.querySelector('.skin-name');
                    if (skinNameElement) {
                        skinNameElement.textContent = skin;
                        console.log(`Updated skin name data for ${currentPick.team}-${currentPick.slot} to ${skin}`);
                    }
                }).catch(error => {
                    console.error('Error updating skin in queue:', error);
                });
            };
            
            // Try loading different image formats
            img.src = `Skins/${skin}.webp`;
            img.onerror = function() {
                this.src = `Skins/${skin}.jpeg`;
                this.onerror = function() {
                    this.src = `Skins/${skin}.png`;
                    this.onerror = function() {
                        this.src = `Skins/${skin}.jpg`;
                        this.onerror = function() {
                            this.src = `Skins/${skin}.jfif`;
                            this.onerror = function() {
                                this.src = `Icons/${selectedChampion}.png`;
                            }
                        }
                    }
                }
            };
            
            // Add to picked champions
            pickedChampions.add(selectedChampion);
            
            // Move to next pick
            currentPickIndex++;
            if (currentPickIndex < pickOrder.length) {
                updateCurrentPick();
                updateAvailableChampions();
                
                if (!isPlayerTurn()) {
                    setTimeout(makeAIPick, 1000);
                }
            }
        }

        // Update makeAIPick to handle skins properly
        async function makeAIPick() {
            const currentPick = pickOrder[currentPickIndex];
            const currentRole = roleAssignments[currentPick.team][currentPick.slot];
            const availableChampions = roles[currentRole].filter(champ => !pickedChampions.has(champ) && !bannedChampions.has(champ)); // Corrected variable name
            
            if (availableChampions.length > 0) {
                const randomChampion = availableChampions[Math.floor(Math.random() * availableChampions.length)];
                
                // Get available skins for the AI champion
                const { characters } = await import('./characterskinref.js');
                const championSkins = characters[randomChampion] || [randomChampion];
                
                // Try up to 5 times to find a different skin
                let selectedSkin = null;
                let attempts = 0;
                const maxAttempts = 5;
                const usedSkins = new Set();

                while (attempts < maxAttempts) {
                    const potentialSkin = championSkins[Math.floor(Math.random() * championSkins.length)];
                    if (!usedSkins.has(potentialSkin)) {
                        selectedSkin = potentialSkin;
                        usedSkins.add(potentialSkin);
                        // 30% chance to try another skin, unless it's the last attempt
                        if (attempts < maxAttempts - 1 && Math.random() < 0.3) {
                            attempts++;
                            await new Promise(resolve => setTimeout(resolve, 100)); // Small delay between attempts
                            continue;
                        }
                        break;
                    }
                    attempts++;
                }

                // If no skin was selected after all attempts, use the default
                const randomSkin = selectedSkin || randomChampion;
                
                const memberElement = document.getElementById(`${currentPick.team}-${currentPick.slot}`);
                
                // Update portrait
                const portrait = memberElement.querySelector('.champion-portrait');
                portrait.innerHTML = `<img src="Icons/${randomChampion}.png" alt="${randomChampion}">`;
                
                // Create the skin-name element if it doesn't exist
                let skinNameElement = memberElement.querySelector('.skin-name');
                if (!skinNameElement) {
                    skinNameElement = document.createElement('div');
                    skinNameElement.className = 'skin-name';
                    memberElement.appendChild(skinNameElement);
                }
                
                // Set the skin name but don't display it
                skinNameElement.textContent = randomSkin;
                console.log(`Set skin name for ${currentPick.team}-${currentPick.slot} to ${randomSkin}`);
                
                // Try different image extensions for the skin with improved error handling
                const img = new Image();
                img.onload = function() {
                    memberElement.style.backgroundImage = `url('${this.src}')`;
                    memberElement.style.backgroundSize = 'cover';
                    memberElement.style.backgroundPosition = 'center';
                    
                    // Force a repaint
                    memberElement.style.display = 'none';
                    memberElement.offsetHeight; // Trigger reflow
                    memberElement.style.display = 'flex';
                };
                
                // Enhanced image loading with multiple retries
                const tryLoadImage = (skin, extensions = ['webp', 'jpeg', 'png', 'jpg', 'jfif']) => {
                    if (extensions.length === 0) {
                        img.src = `Icons/${randomChampion}.png`;
                        return;
                    }
                    
                    img.src = `Skins/${skin}.${extensions[0]}`;
                    img.onerror = () => tryLoadImage(skin, extensions.slice(1));
                };
                
                tryLoadImage(randomSkin);
                
                // Update the queue data with the selected skin
                const queueRef = ref(database, `Queue/${queueId}/players/${currentPick.team}_${currentPick.slot}`);
                update(queueRef, {
                    skin: randomSkin,
                    champion: randomChampion
                }).then(() => {
                    console.log('AI selected skin updated in queue data:', randomSkin);
                    
                    // Update the skin name in the data but don't show it
                    const skinNameElement = memberElement.querySelector('.skin-name');
                    if (skinNameElement) {
                        skinNameElement.textContent = randomSkin;
                        console.log(`Updated skin name data for ${currentPick.team}-${currentPick.slot} to ${randomSkin}`);
                    }
                }).catch(error => {
                    console.error('Error updating AI skin in queue:', error);
                });
                
                pickedChampions.add(randomChampion);
                checkAllChampionsSelected(); // Check after each pick
                
                currentPickIndex++;
                if (currentPickIndex < pickOrder.length) {
                    updateCurrentPick();
                    updateAvailableChampions();
                    
                    if (!isPlayerTurn()) {
                        setTimeout(makeAIPick, 1000);
                    }
                } else {
                    // This is the last pick, make sure to check one final time
                    checkAllChampionsSelected();
                    // Remove the picking highlight from all members since picks are done
                    document.querySelectorAll('.team-member').forEach(member => {
                        member.classList.remove('picking');
                    });
                }
            }
        }

        // Check if it's player's turn
        function isPlayerTurn() {
            const currentPick = pickOrder[currentPickIndex];
            return currentPick && currentPick.team === playerTeam && currentPick.slot === playerSlot;
        }

        // Initialize the game
        function initializeGame() {
            // Assign the selected role to the player's slot
            roleAssignments[playerTeam][playerSlot] = selectedRole;
            
            // Generate other role assignments
            const allRoles = ['Top', 'Jungle', 'Mid', 'Adc', 'Support'];
            
            // Assign remaining roles for blue team
            const blueAvailableRoles = allRoles.filter(r => r !== (playerTeam === 'blue' ? selectedRole : null));
            for (let slot = 1; slot <= 5; slot++) {
                if (playerTeam !== 'blue' || slot !== playerSlot) {
                    const randomIndex = Math.floor(Math.random() * blueAvailableRoles.length);
                    roleAssignments.blue[slot] = blueAvailableRoles.splice(randomIndex, 1)[0];
                }
            }
            
            // Assign roles for red team
            const redAvailableRoles = allRoles.filter(r => r !== (playerTeam === 'red' ? selectedRole : null));
            for (let slot = 1; slot <= 5; slot++) {
                if (playerTeam !== 'red' || slot !== playerSlot) {
                    const randomIndex = Math.floor(Math.random() * redAvailableRoles.length);
                    roleAssignments.red[slot] = redAvailableRoles.splice(randomIndex, 1)[0];
                }
            }

            // Generate pick order
            const blueTeam = [1, 2, 3, 4, 5].map(num => ({ team: 'blue', slot: num }));
            const redTeam = [1, 2, 3, 4, 5].map(num => ({ team: 'red', slot: num }));
            
            pickOrder = [
                blueTeam[0],                    // Blue 1st pick
                redTeam[0], redTeam[1],         // Red 1st & 2nd pick
                blueTeam[1], blueTeam[2],       // Blue 2nd & 3rd pick
                redTeam[2], redTeam[3],         // Red 3rd & 4th pick
                blueTeam[3], blueTeam[4],       // Blue 4th & 5th pick
                redTeam[4]                      // Red 5th pick
            ];

            updatePickOrderDisplay();
            updateAvailableChampions();

            // Start AI picks if player isn't first
            if (!isPlayerTurn()) {
                makeAIPick();
            }

            // Start AI chat system
            startAIChat();
        }

        // Update pick order display
        function updatePickOrderDisplay() {
            pickOrder.forEach((pick, index) => {
                const memberElement = document.getElementById(`${pick.team}-${pick.slot}`);
                const indicator = memberElement.querySelector('.pick-order-indicator');
                indicator.textContent = `Pick ${index + 1}`;
                
                // Show assigned role
                const playerInfo = memberElement.querySelector('.player-info');
                const roleText = document.createElement('div');
                roleText.className = 'player-role';
                roleText.textContent = roleAssignments[pick.team][pick.slot];
                playerInfo.appendChild(roleText);

                // Only update rank points if it's not already set
                if (!(pick.team === playerTeam && pick.slot === playerSlot)) {
                    const rankElement = memberElement.querySelector('.player-rank');
                    const aiKey = `${pick.team}_${pick.slot}`;
                    rankElement.textContent = `${aiPlayerRankPoints[aiKey]} RP`;
                }
            });

            // Highlight current pick
            updateCurrentPick();
        }

        // Update available champions based on current role
        function updateAvailableChampions() {
            const currentPick = pickOrder[currentPickIndex];
            const currentRole = roleAssignments[currentPick.team][currentPick.slot];
            const availableChampions = roles[currentRole];

            document.querySelectorAll('.champion-card').forEach(card => {
                const champion = card.title;
                card.classList.remove('available');
                
                if (availableChampions.includes(champion) && !pickedChampions.has(champion) && !bannedChampions.has(champion)) {
                    card.classList.add('available');
                }
            });
        }

        // Update current pick highlight
        function updateCurrentPick() {
            document.querySelectorAll('.team-member').forEach(member => {
                member.classList.remove('picking');
            });

            if (currentPickIndex < pickOrder.length) {
                const currentPick = pickOrder[currentPickIndex];
                const memberElement = document.getElementById(`${currentPick.team}-${currentPick.slot}`);
                memberElement.classList.add('picking');
            }
        }

        // Update initializeChampionGrid to handle role-based availability
        function initializeChampionGrid() {
            const championGrid = document.querySelector('.champion-grid');
            championGrid.innerHTML = '';
            
            const allChampions = new Set();
            Object.values(roles).forEach(roleChamps => {
                roleChamps.forEach(champ => allChampions.add(champ));
            });

            // Convert Set to Array and sort alphabetically
            const sortedChampions = Array.from(allChampions).sort((a, b) => a.localeCompare(b));

            // Load meta data for winrates and tiers
            fetch('meta.json')
                .then(response => response.json())
                .then(metaData => {
                    sortedChampions.forEach(champion => {
                        const card = document.createElement('div');
                        card.className = 'champion-card';
                        card.title = champion;
                        
                        const img = document.createElement('img');
                        img.src = `Icons/${champion}.png`;
                        img.alt = champion;
                        
                        // Add champion name display
                        const nameDiv = document.createElement('div');
                        nameDiv.className = 'champion-name';
                        nameDiv.textContent = champion;
                        
                        // Add winrate and tier display
                        const metaInfo = document.createElement('div');
                        metaInfo.className = 'champion-meta';
                        
                        // Get winrate from meta data (or default to 0)
                        const winrate = metaData[champion] || 0;
                        
                        // Determine tier based on winrate
                        let tier, tierClass;
                        if (winrate >= 53) {
                            tier = 'S+';
                            tierClass = 'tier-sp';
                        } else if (winrate >= 51) {
                            tier = 'S';
                            tierClass = 'tier-s';
                        } else if (winrate >= 49) {
                            tier = 'A';
                            tierClass = 'tier-a';
                        } else if (winrate >= 47) {
                            tier = 'B';
                            tierClass = 'tier-b';
                        } else if (winrate >= 45) {
                            tier = 'C';
                            tierClass = 'tier-c';
                        } else {
                            tier = 'D';
                            tierClass = 'tier-d';
                        }
                        
                        // Create tier element
                        const tierSpan = document.createElement('span');
                        tierSpan.className = `champion-tier ${tierClass}`;
                        tierSpan.textContent = tier;
                        
                        // Create winrate element
                        const winrateSpan = document.createElement('span');
                        winrateSpan.className = 'champion-winrate';
                        winrateSpan.textContent = `${winrate}%`;
                        
                        metaInfo.appendChild(tierSpan);
                        metaInfo.appendChild(winrateSpan);
                        
                        card.appendChild(img);
                        card.appendChild(nameDiv);
                        card.appendChild(metaInfo);
                        championGrid.appendChild(card);

                        // Check if champion is banned
                        if (bannedChampions.has(champion)) {
                            card.classList.add('banned-champion');
                            return;
                        }

                        // Check if champion is available for current role
                        const isAvailableForRole = roles[selectedRole]?.includes(champion);
                        if (!isAvailableForRole) {
                            card.classList.add('unavailable');
                        }

                        card.addEventListener('click', () => {
                            if (isPlayerTurn() && card.classList.contains('available') && isAvailableForRole && !bannedChampions.has(champion)) {
                                selectChampion(champion);
                            }
                        });
                    });
                    
                    // Update available champions after loading
                    updateAvailableChampions();
                })
                .catch(error => {
                    console.error('Error loading meta data:', error);
                    // Fallback to initialize grid without meta data
                    sortedChampions.forEach(champion => {
                        const card = document.createElement('div');
                        card.className = 'champion-card';
                        card.title = champion;
                        
                        const img = document.createElement('img');
                        img.src = `Icons/${champion}.png`;
                        img.alt = champion;
                        
                        const nameDiv = document.createElement('div');
                        nameDiv.className = 'champion-name';
                        nameDiv.textContent = champion;
                        
                        card.appendChild(img);
                        card.appendChild(nameDiv);
                        championGrid.appendChild(card);

                        if (bannedChampions.has(champion)) {
                            card.classList.add('banned-champion');
                            return;
                        }

                        const isAvailableForRole = roles[selectedRole]?.includes(champion);
                        if (!isAvailableForRole) {
                            card.classList.add('unavailable');
                        }

                        card.addEventListener('click', () => {
                            if (isPlayerTurn() && card.classList.contains('available') && isAvailableForRole && !bannedChampions.has(champion)) {
                                selectChampion(champion);
                            }
                        });
                    });
                    
                    updateAvailableChampions();
                });
        }

        // Role selection handling
        function handleRoleSelection(role) {
            const modal = document.getElementById('roleSelectModal');
            selectedRole = role;
            modal.style.display = 'none';
            
            // Generate pick order first
            const blueTeam = [1, 2, 3, 4, 5].map(num => ({ team: 'blue', slot: num }));
            const redTeam = [1, 2, 3, 4, 5].map(num => ({ team: 'red', slot: num }));
            
            pickOrder = [
                blueTeam[0],                    // Blue 1st pick
                redTeam[0], redTeam[1],         // Red 1st & 2nd pick
                blueTeam[1], blueTeam[2],       // Blue 2nd & 3rd pick
                redTeam[2], redTeam[3],         // Red 3rd & 4th pick
                blueTeam[3], blueTeam[4],       // Blue 4th & 5th pick
                redTeam[4]                      // Red 5th pick
            ];
            
            // Start ban phase
            startBanPhase();
        }

        // Add event listeners for role selection
        document.querySelectorAll('.role-select-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                handleRoleSelection(btn.dataset.role);
            });
        });

        // Add chat system functions
        function getRandomMessage(messageArray) {
            return messageArray[Math.floor(Math.random() * messageArray.length)];
        }

        // Initialize chat messages container
        const chatMessagesContainer = document.querySelector('.chat-messages');

        function addChatMessage(name, message, team) {
            // Only show messages from the player's team
            if (team === playerTeam) {
                const chatDiv = document.createElement('div');
                chatDiv.className = 'chat-message';
                
                const sender = document.createElement('span');
                sender.className = 'sender';
                sender.textContent = name;
                
                const messageText = document.createElement('span');
                messageText.className = 'message-text';
                messageText.textContent = message;
                
                chatDiv.appendChild(sender);
                chatDiv.appendChild(messageText);
                
                const chatMessagesContainer = document.querySelector('.chat-messages');
                chatMessagesContainer.appendChild(chatDiv);
                chatMessagesContainer.scrollTop = chatMessagesContainer.scrollHeight;
            }
        }

        // AI Chat System
        function startAIChat() {
            // Initial greetings from 1-2 team AI players
            setTimeout(() => {
                const numGreetings = 1 + Math.floor(Math.random() * 2); // 1 or 2 players
                for (let i = 0; i < numGreetings; i++) {
                    // Only pick from player's team slots (excluding player's slot)
                    let slot;
                    do {
                        slot = 1 + Math.floor(Math.random() * 5);
                    } while (slot === playerSlot);
                    
                    const aiName = document.querySelector(`#${playerTeam}-${slot} .player-name`).textContent;
                    addChatMessage(aiName, getRandomMessage(chatMessages.greetings), playerTeam);
                }
            }, 1000);

            // Role preferences discussion (1-2 players)
            setTimeout(() => {
                const numRolePref = 1 + Math.floor(Math.random() * 2); // 1 or 2 players
                for (let i = 0; i < numRolePref; i++) {
                    let slot;
                    do {
                        slot = 1 + Math.floor(Math.random() * 5);
                    } while (slot === playerSlot);

                    const aiName = document.querySelector(`#${playerTeam}-${slot} .player-name`).textContent;
                    addChatMessage(aiName, getRandomMessage(chatMessages.rolePreferences), playerTeam);
                }
            }, 3000);

            // Regular AI chat during champion select
            let chatInterval = setInterval(() => {
                // Increased chance to send a message (e.g., 70%)
                if (Math.random() < 0.7) { 
                    let slot;
                    do {
                        slot = 1 + Math.floor(Math.random() * 5);
                    } while (slot === playerSlot);

                    const aiName = document.querySelector(`#${playerTeam}-${slot} .player-name`).textContent;
                    
                    // Select message category more broadly
                    const messageCategories = [
                        chatMessages.teamComp, 
                        chatMessages.strategy, 
                        chatMessages.metaDiscussion,
                        chatMessages.skinComments,
                        chatMessages.banterTrashTalk,
                        chatMessages.eventChat, // Added event chat
                        contextualResponses.goodComp, 
                        contextualResponses.badComp,
                        timeBasedMessages.early, 
                        timeBasedMessages.middle, 
                        timeBasedMessages.late
                    ];

                    // Add role-specific banter from the AI's assigned role
                    const aiRole = roleAssignments[playerTeam][slot];
                    if (aiRole && chatMessages.roleSpecificBanter[aiRole.toLowerCase()] && Math.random() < 0.3) {
                        messageCategories.push(chatMessages.roleSpecificBanter[aiRole.toLowerCase()]);
                    }
                    
                    const randomCategory = messageCategories[Math.floor(Math.random() * messageCategories.length)];
                    addChatMessage(aiName, getRandomMessage(randomCategory), playerTeam);
                }
            }, 4000); // Reduced interval to 4 seconds for more frequent messages

            // Reaction to picks
            document.addEventListener('championPicked', (event) => {
                // Increased chance to comment on picks (e.g., 60%)
                if (Math.random() < 0.6) { 
                    let slot;
                    do {
                        slot = 1 + Math.floor(Math.random() * 5);
                    } while (slot === playerSlot);

                    const aiName = document.querySelector(`#${playerTeam}-${slot} .player-name`).textContent;
                    
                    const isPositive = Math.random() < 0.6; // 60% chance for positive reaction
                    const reactionType = isPositive ? chatMessages.championReactions.positive : chatMessages.championReactions.negative;
                    const message = getRandomMessage(reactionType);
                    
                    setTimeout(() => {
                        addChatMessage(aiName, message, playerTeam);
                    }, 750); // Reduced delay
                }
            });
        }

        // Update the chat input event listener
        chatInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter' && chatInput.value.trim()) {
                const playerName = document.getElementById(`${playerTeam}-${playerSlot}`).querySelector('.player-name').textContent;
                addChatMessage(playerName, chatInput.value.trim(), playerTeam);
                chatInput.value = '';

                // Trigger AI response with higher chance (e.g., 75%)
                if (Math.random() < 0.75) { 
                    setTimeout(() => {
                        let slot;
                        do {
                            slot = 1 + Math.floor(Math.random() * 5);
                        } while (slot === playerSlot);

                        const aiName = document.querySelector(`#${playerTeam}-${slot} .player-name`).textContent;
                        
                        // Broader categories for response
                        const messageCategories = [
                            chatMessages.teamComp,
                            chatMessages.strategy,
                            chatMessages.encouragement,
                            chatMessages.metaDiscussion,
                            chatMessages.skinComments,
                            chatMessages.banterTrashTalk,
                            chatMessages.eventChat, // Added event chat
                            contextualResponses.goodComp,
                            contextualResponses.needsAP, // Added more contextual options
                            contextualResponses.needsAD,
                            contextualResponses.needsCC,
                            contextualResponses.needsTank,
                            timeBasedMessages.middle
                        ];
                        const aiRole = roleAssignments[playerTeam][slot];
                        if (aiRole && chatMessages.roleSpecificBanter[aiRole.toLowerCase()] && Math.random() < 0.3) {
                        messageCategories.push(chatMessages.roleSpecificBanter[aiRole.toLowerCase()]);
                    }
                        
                        addChatMessage(aiName, getRandomMessage(messageCategories[Math.floor(Math.random() * messageCategories.length)]), playerTeam);
                    }, 1000 + Math.random() * 1000); // Slightly reduced random delay
                }
            }
        });

        // Add function to check if all champions are selected
        function checkAllChampionsSelected() {
            const startMatchButton = document.querySelector('.start-match-button');
            if (pickedChampions.size === 10) {
                startMatchButton.disabled = false;
                startMatchButton.classList.add('ready');
                // Make sure the cursor is a pointer when ready
                startMatchButton.style.cursor = 'pointer';
            } else {
                startMatchButton.disabled = true;
                startMatchButton.classList.remove('ready');
                startMatchButton.style.cursor = 'not-allowed';
            }
        }

        // Add start match button functionality
        document.querySelector('.start-match-button').addEventListener('click', async function() {
            if (this.classList.contains('ready')) {
                try {
                    // Generate a unique queue ID
                    const queueId = Date.now().toString(36) + Math.random().toString(36).substr(2);
                    
                    // Get current user's data for profile icon
                    const userRef = ref(database, `users/${auth.currentUser.uid}`);
                    const userSnapshot = await get(userRef);
                    const userData = userSnapshot.val();
                    
                    // Collect game information
                    const gameInfo = {
                        queueId,
                        timestamp: Date.now(),
                        players: {},
                        bans: {
                            blue: document.getElementById('blueBanPortrait').querySelector('img')?.alt || null,
                            red: document.getElementById('redBanPortrait').querySelector('img')?.alt || null
                        }
                    };

                    // Define role to slot mapping
                    const roleToSlot = {
                        'Top': 1,
                        'Jungle': 2,
                        'Mid': 3,
                        'Adc': 4,
                        'Support': 5
                    };

                    // Collect information for all players
                    for (let team of ['blue', 'red']) {
                        // Create a temporary map to store players by role
                        const roleMap = new Map();
                        
                        // First, collect all players and their roles
                        for (let slot = 1; slot <= 5; slot++) {
                            const memberElement = document.getElementById(`${team}-${slot}`);
                            if (!memberElement) {
                                console.error(`Could not find element for ${team}-${slot}`);
                                continue;
                            }

                            const role = roleAssignments[team][slot];
                            if (!role) {
                                console.error(`No role assignment found for ${team}-${slot}`);
                                continue;
                            }

                            const playerName = memberElement.querySelector('.player-name')?.textContent;
                            const championPortrait = memberElement.querySelector('.champion-portrait img');
                            const champion = championPortrait ? championPortrait.alt : null;
                            
                            // Get skin data from the UI element instead of trying to fetch from database
                            // (The database won't have data yet because we just created this queueId)
                            let skin;
                            const skinNameElement = memberElement.querySelector('.skin-name');
                            if (skinNameElement && skinNameElement.textContent) {
                                skin = skinNameElement.textContent;
                                console.log(`Retrieved skin '${skin}' from UI for ${team}-${slot}`);
                            } else {
                                // If no skin is set in UI, default to champion name
                                skin = champion;
                                console.log(`No skin found in UI for ${team}-${slot}, defaulting to '${champion}'`);
                            }
                            
                            if (!champion) {
                                console.error(`No champion found for ${team}-${slot}`);
                                continue;
                            }

                            // Store player data by their role
                            roleMap.set(role, {
                                name: playerName,
                                champion,
                                skin,
                                role,
                                originalSlot: slot
                            });
                        }

                        // Then, assign players to the correct slots based on their roles
                        for (const [role, playerData] of roleMap) {
                            const correctSlot = roleToSlot[role];
                            if (!correctSlot) {
                                console.error(`Invalid role mapping for ${role}`);
                                continue;
                            }

                            const isPlayerSlot = team === playerTeam && playerData.originalSlot === playerSlot;
                            
                            if (isPlayerSlot) {
                                // Player slot
                                gameInfo.players[`${team}_${correctSlot}`] = {
                                    name: playerData.name,
                                    champion: playerData.champion,
                                    skin: playerData.skin,
                                    build: selectedBuild,
                                    role: role,
                                    team,
                                    isAI: false,
                                    uid: auth.currentUser.uid,
                                    profileIcon: userData.icon || 'Birdie.png',
                                    playerSlot: correctSlot,
                                    playerTeam: team
                                };
                                console.log(`Saved player data for ${team}_${correctSlot} (${role}):`, gameInfo.players[`${team}_${correctSlot}`]);
                            } else {
                                // AI players
                                gameInfo.players[`${team}_${correctSlot}`] = {
                                    name: playerData.name,
                                    champion: playerData.champion,
                                    skin: playerData.skin,
                                    build: null,
                                    role: role,
                                    team,
                                    isAI: true
                                };
                                console.log(`Saved AI data for ${team}_${correctSlot} (${role}):`, gameInfo.players[`${team}_${correctSlot}`]);
                            }
                        }
                    }

                    // Verify all slots are populated
                    for (let team of ['blue', 'red']) {
                        for (let slot = 1; slot <= 5; slot++) {
                            const key = `${team}_${slot}`;
                            if (!gameInfo.players[key]) {
                                console.error(`Missing player data for ${key} (${Object.keys(roleToSlot).find(role => roleToSlot[role] === slot)})`);
                            }
                        }
                    }

                    // Save to Firebase
                    console.log('Saving queue data:', gameInfo);
                    const queueRef = ref(database, `Queue/${queueId}`);
                    await set(queueRef, gameInfo);

                    // Play Tokyo Mew Mew transition animation
                    playMewMewTransition(queueId);

                } catch (error) {
                    console.error('Error starting game:', error);
                    // Re-enable the button if there's an error
                    this.disabled = false;
                    this.textContent = 'START MATCH';
                    alert('Error starting the game. Please try again.');
                }
            }
        });

        // Tokyo Mew Mew Transition Animation
        function playMewMewTransition(queueId) {
            const transition = document.getElementById('mewMewTransition');
            const sparkleContainer = document.getElementById('sparkleContainer');
            
            // Create Tokyo Mew Mew transformation sound
            const transformSound = new Audio('Songs/mew_mew_transform.mp3');
            transformSound.volume = audio.volume; // Match current volume
            transformSound.play().catch(err => console.log('Could not play transformation sound:', err));
            
            // Activate transition
            transition.classList.add('active');
            
            // Generate sparkles
            for (let i = 0; i < 50; i++) {
                setTimeout(() => {
                    createSparkle(sparkleContainer);
                }, i * 40);
            }
            
            // Generate hearts
            for (let i = 0; i < 20; i++) {
                setTimeout(() => {
                    createHeart(sparkleContainer);
                }, 500 + i * 100);
            }
            
            // Redirect after animation completes
            setTimeout(() => {
                // Store queue ID in sessionStorage for Game.html to access
                sessionStorage.setItem('currentQueueId', queueId);
                window.location.href = 'Game.html';
            }, 3000);
        }
        
        function createSparkle(container) {
            const sparkle = document.createElement('div');
            sparkle.className = 'sparkle';
            
            // Random position
            const x = Math.random() * window.innerWidth;
            const y = Math.random() * window.innerHeight;
            sparkle.style.left = `${x}px`;
            sparkle.style.top = `${y}px`;
            
            // Random movement direction
            const tx = (Math.random() - 0.5) * 300;
            const ty = (Math.random() - 0.5) * 300;
            sparkle.style.setProperty('--tx', `${tx}px`);
            sparkle.style.setProperty('--ty', `${ty}px`);
            
            // Random color - cycle through Mew Mew colors
            const colors = ['var(--mew-pink)', 'var(--mew-light-pink)', 'var(--mew-blue)', 
                           'var(--mew-green)', 'var(--mew-yellow)', 'var(--mew-purple)'];
            const randomColor = colors[Math.floor(Math.random() * colors.length)];
            sparkle.style.filter = `hue-rotate(${Math.random() * 360}deg)`;
            
            // Random size
            const size = 10 + Math.random() * 20;
            sparkle.style.width = `${size}px`;
            sparkle.style.height = `${size}px`;
            
            // Random delay
            sparkle.style.animationDelay = `${Math.random() * 0.5}s`;
            
            container.appendChild(sparkle);
            
            // Remove element after animation
            setTimeout(() => {
                sparkle.remove();
            }, 2500);
        }
        
        function createHeart(container) {
            const heart = document.createElement('div');
            heart.className = 'heart';
            
            // Random position
            const x = window.innerWidth / 2 + (Math.random() - 0.5) * 300;
            const y = window.innerHeight / 2 + (Math.random() - 0.5) * 300;
            heart.style.left = `${x}px`;
            heart.style.top = `${y}px`;
            
            // Random movement direction
            const tx = (Math.random() - 0.5) * 400;
            const ty = (Math.random() - 0.5) * 400;
            heart.style.setProperty('--tx', `${tx}px`);
            heart.style.setProperty('--ty', `${ty}px`);
            
            // Random size
            const size = 15 + Math.random() * 25;
            heart.style.width = `${size}px`;
            heart.style.height = `${size}px`;
            
            // Random rotation
            heart.style.transform = `rotate(${Math.random() * 360}deg)`;
            
            // Random color - pink/red variations
            heart.style.filter = `hue-rotate(${Math.random() * 60 - 30}deg) saturate(${1 + Math.random()}`;
            
            // Random delay
            heart.style.animationDelay = `${Math.random() * 0.5}s`;
            
            container.appendChild(heart);
            
            // Remove element after animation
            setTimeout(() => {
                heart.remove();
            }, 3000);
        }

        // Add like build functionality
        async function likeBuild(buildId, buildPatchVersion) { // Added buildPatchVersion parameter
            try {
                const user = auth.currentUser;
                if (!user) return;

                const buildRef = ref(database, `builds/${buildPatchVersion}/${buildId}`); // USE buildPatchVersion
                const snapshot = await get(buildRef);
                
                if (snapshot.exists()) {
                    const build = snapshot.val();
                    const likes = (build.likes || 0) + 1;
                    await update(buildRef, { likes }); 
                    
                    const modal = document.getElementById('buildSelectionModal');
                    const allLikeButtons = modal.querySelectorAll(`.build-card button.rating-button`);
                    allLikeButtons.forEach(btn => {
                        const onclickAttr = btn.getAttribute('onclick');
                        if (onclickAttr && onclickAttr.includes(`likeBuild('${buildId}'`) && onclickAttr.includes(`'${buildPatchVersion}'`)) {
                            btn.classList.add('liked');
                            const likesSpan = btn.querySelector('span');
                            if (likesSpan) {
                                likesSpan.textContent = likes;
                            }
                        }
                    });
                }
            } catch (error) {
                console.error('Error liking build:', error);
            }
        }

        // Add build selection functionality
        document.getElementById('loadBuildButton').addEventListener('click', async () => {
            const modal = document.getElementById('buildSelectionModal');
            const buildGrid = document.getElementById('buildGrid');
            buildGrid.innerHTML = ''; // Clear previous builds

            try {
                const allBuilds = [];
                const allPatchesRef = ref(database, 'builds');
                const patchesSnapshot = await get(allPatchesRef);

                if (patchesSnapshot.exists()) {
                    const patchPromises = [];
                    patchesSnapshot.forEach(patchChild => {
                        const patchKey = patchChild.key; // e.g., "2_1_1", "2_5"
                        const buildsPerPatchRef = ref(database, `builds/${patchKey}`);
                        patchPromises.push(get(buildsPerPatchRef).then(buildsSnapshot => {
                            if (buildsSnapshot.exists()) {
                                buildsSnapshot.forEach(childSnapshot => {
                                    const build = childSnapshot.val();
                                    if (build.character === selectedChampion) {
                                        allBuilds.push({
                                            id: childSnapshot.key,
                                            patchForDisplay: patchKey.replace(/_/g, '.'), // For displaying "Patch X.Y"
                                            patchForDB: patchKey, // For internal use like liking "2_1_1"
                                            ...build
                                        });
                                    }
                                });
                            }
                        }));
                    });
                    await Promise.all(patchPromises);
                }

                if (allBuilds.length > 0) {
                    allBuilds.sort((a, b) => (b.likes || 0) - (a.likes || 0));

                    allBuilds.forEach(build => {
                        const card = document.createElement('div');
                        card.className = 'build-card';

                        const header = document.createElement('div');
                        header.className = 'build-header';
                        header.innerHTML = `
                            <div class="build-title">${build.name || 'Unnamed Build'}</div>
                            <div class="build-info">
                                <span>by ${build.creatorName || 'Anonymous'}</span>
                                <span>• Patch ${build.patchForDisplay}</span>
                            </div>
                        `;

                        const items = document.createElement('div');
                        items.className = 'build-items';
                        
                        build.items.forEach(itemId => {
                            if (itemId) {
                                const itemDiv = document.createElement('div');
                                itemDiv.className = 'build-item';
                                const img = document.createElement('img');
                                
                                img.onerror = function() {
                                    if (this.src.endsWith('.webp')) {
                                        this.src = `Items/${itemId}.jpeg`;
                                    } else if (this.src.endsWith('.jpeg')) {
                                        this.src = `Items/${itemId}.png`;
                                    } else if (this.src.endsWith('.png')) {
                                        this.src = `Items/${itemId}.jpg`;
                                    }
                                };
                                
                                img.src = `Items/${itemId}.webp`;
                                img.alt = itemId;
                                itemDiv.appendChild(img);
                                items.appendChild(itemDiv);
                            }
                        });

                        const actions = document.createElement('div');
                        actions.className = 'build-actions';
                        
                        const likeButton = document.createElement('button');
                        likeButton.className = `rating-button ${build.likedByCurrentUser ? 'liked' : ''}`; 
                        likeButton.innerHTML = `
                            <i class="fas fa-thumbs-up"></i>
                            <span>${build.likes || 0}</span>
                        `;
                        likeButton.onclick = () => likeBuild(build.id, build.patchForDB);

                        const loadButton = document.createElement('button');
                        loadButton.className = 'copy-build';
                        loadButton.innerHTML = '<i class="fas fa-check"></i> Select Build';
                        loadButton.onclick = () => {
                            selectBuild(build); 
                            modal.style.display = 'none';
                        };

                        actions.appendChild(likeButton);
                        actions.appendChild(loadButton);

                        card.appendChild(header);
                        card.appendChild(items);
                        card.appendChild(actions);
                        buildGrid.appendChild(card);
                    });
                } else {
                    buildGrid.innerHTML = `
                        <div style="text-align: center; padding: 20px; color: var(--text-color);">
                            No builds found for ${selectedChampion}. 
                            <br><br>
                            <button class="copy-build" onclick="location.href='build-planner.html?character=${encodeURIComponent(selectedChampion)}'">
                                <i class="fas fa-plus"></i> Create New Build
                            </button>
                        </div>
                    `;
                }
                modal.style.display = 'flex';
            } catch (error) {
                console.error('Error loading builds:', error);
                // Corrected template literal for error message
                buildGrid.innerHTML = ` 
                    <div style="text-align: center; padding: 20px; color: var(--text-color);">
                        Error loading builds. Please try again later. (${error.message})
                    </div>
                `;
                modal.style.display = 'flex';
            }
        });

        // Update selectBuild function to store player team info
        async function selectBuild(build) {
            const currentPick = pickOrder[currentPickIndex - 1];
            const memberElement = document.getElementById(`${currentPick.team}-${currentPick.slot}`);
            
            // Store the selected build and player team info
            selectedBuild = build;
            
            // Update the UI to show the build has been selected
            const loadBuildButton = document.getElementById('loadBuildButton');
            loadBuildButton.innerHTML = '<i class="fas fa-check"></i> Build Selected';
            loadBuildButton.classList.remove('available');
            loadBuildButton.classList.add('selected');
            
            // Dispatch a custom event that a build was selected
            const event = new CustomEvent('buildSelected', { 
                detail: { 
                    build, 
                    team: currentPick.team,
                    playerTeam: playerTeam,
                    playerSlot: playerSlot
                } 
            });
            document.dispatchEvent(event);
        }

        // Add Font Awesome for icons
        const fontAwesome = document.createElement('link');
        fontAwesome.rel = 'stylesheet';
        fontAwesome.href = 'https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css';
        document.head.appendChild(fontAwesome);

        // Add game state variables for bans
        let bannedChampions = new Set();
        let currentBanTeam = 'blue';
        let banPhaseComplete = false;

        // Add ban system functions
        async function startBanPhase() {
            console.log('Starting ban phase');
            const modal = document.getElementById('banModal');
            const banGrid = document.getElementById('banGrid');
            const phaseInfo = document.querySelector('.ban-phase-info p');
            banGrid.innerHTML = '';
            
            try {
                // Load meta data
                const response = await fetch('meta.json');
                const metaData = await response.json();
                
                // Create champion cards for banning
                const allChampions = new Set();
                Object.values(roles).forEach(roleChamps => {
                    roleChamps.forEach(champ => allChampions.add(champ));
                });

                // Convert Set to Array and sort alphabetically
                const sortedChampions = Array.from(allChampions).sort((a, b) => a.localeCompare(b));

                sortedChampions.forEach(champion => {
                    const card = document.createElement('div');
                    card.className = 'ban-card';
                    card.title = champion;
                    
                    const img = document.createElement('img');
                    img.src = `Icons/${champion}.png`;
                    img.alt = champion;
                    
                    // Add champion name display
                    const nameDiv = document.createElement('div');
                    nameDiv.className = 'champion-name';
                    nameDiv.textContent = champion;
                    
                    // Add winrate and tier display
                    const metaInfo = document.createElement('div');
                    metaInfo.className = 'champion-meta';
                    
                    // Get winrate from meta data (or default to 0)
                    const winrate = metaData[champion] || 0;
                    
                    // Determine tier based on winrate
                    let tier, tierClass;
                    if (winrate >= 53) {
                        tier = 'S+';
                        tierClass = 'tier-sp';
                    } else if (winrate >= 51) {
                        tier = 'S';
                        tierClass = 'tier-s';
                    } else if (winrate >= 49) {
                        tier = 'A';
                        tierClass = 'tier-a';
                    } else if (winrate >= 47) {
                        tier = 'B';
                        tierClass = 'tier-b';
                    } else if (winrate >= 45) {
                        tier = 'C';
                        tierClass = 'tier-c';
                    } else {
                        tier = 'D';
                        tierClass = 'tier-d';
                    }
                    
                    // Create tier element
                    const tierSpan = document.createElement('span');
                    tierSpan.className = `champion-tier ${tierClass}`;
                    tierSpan.textContent = tier;
                    
                    // Create winrate element
                    const winrateSpan = document.createElement('span');
                    winrateSpan.className = 'champion-winrate';
                    winrateSpan.textContent = `${winrate}%`;
                    
                    metaInfo.appendChild(tierSpan);
                    metaInfo.appendChild(winrateSpan);
                    
                    card.appendChild(img);
                    card.appendChild(nameDiv);
                    card.appendChild(metaInfo);
                    banGrid.appendChild(card);

                    card.addEventListener('click', () => handleBanSelection(champion));
                });

                // Update phase info text
                phaseInfo.textContent = `${currentBanTeam.toUpperCase()} Team Ban Phase`;

                // Show modal if it's player's turn to ban
                if (isPlayerFirstPick()) {
                    modal.style.display = 'flex';
                    phaseInfo.textContent = `Your turn to ban`;
                } else {
                    await makeAIBan();
                }
            } catch (error) {
                console.error('Error loading meta data:', error);
                
                // Fallback if meta data loading fails
                const allChampions = new Set();
                Object.values(roles).forEach(roleChamps => {
                    roleChamps.forEach(champ => allChampions.add(champ));
                });

                const sortedChampions = Array.from(allChampions).sort((a, b) => a.localeCompare(b));

                sortedChampions.forEach(champion => {
                    const card = document.createElement('div');
                    card.className = 'ban-card';
                    card.title = champion;
                    
                    const img = document.createElement('img');
                    img.src = `Icons/${champion}.png`;
                    img.alt = champion;
                    
                    // Add champion name display
                    const nameDiv = document.createElement('div');
                    nameDiv.className = 'champion-name';
                    nameDiv.textContent = champion;
                    
                    card.appendChild(img);
                    card.appendChild(nameDiv);
                    banGrid.appendChild(card);

                    card.addEventListener('click', () => handleBanSelection(champion));
                });

                // Update phase info text
                phaseInfo.textContent = `${currentBanTeam.toUpperCase()} Team Ban Phase`;

                // Show modal if it's player's turn to ban
                if (isPlayerFirstPick()) {
                    modal.style.display = 'flex';
                    phaseInfo.textContent = `Your turn to ban`;
                } else {
                    await makeAIBan();
                }
            }
        }

        // Update isPlayerFirstPick to handle first pick of each team
        function isPlayerFirstPick() {
            if (currentBanTeam === 'blue') {
                return playerTeam === 'blue' && playerSlot === pickOrder[0].slot;
            } else {
                return playerTeam === 'red' && playerSlot === pickOrder[1].slot;
            }
        }

        // Update handleBanSelection to handle team-based banning
        async function handleBanSelection(champion) {
            if (currentBanTeam === playerTeam && isPlayerFirstPick()) {
                console.log(`Player banning ${champion} for ${currentBanTeam} team`);
                await banChampion(champion);
                currentBanTeam = currentBanTeam === 'blue' ? 'red' : 'blue';
                
                // Update phase info text after ban
                const phaseInfo = document.querySelector('.ban-phase-info p');
                phaseInfo.textContent = `${currentBanTeam.toUpperCase()} Team Ban Phase`;
                
                if (currentBanTeam !== playerTeam || !isPlayerFirstPick()) {
                    await makeAIBan();
                }
            }
        }

        async function makeAIBan() {
            console.log('AI making ban decision...');
            try {
                // Load meta data
                const response = await fetch('meta.json');
                const meta = await response.json();

                // Get available champions that haven't been banned
                const availableChampions = Array.from(new Set(
                    Object.values(roles).flat()
                )).filter(champ => !bannedChampions.has(champ));

                if (availableChampions.length > 0) {
                    let championToBan;

                    // 80% chance to ban a high tier character
                    if (Math.random() < 0.8) {
                        // Sort champions by their meta score (winrate)
                        const sortedChampions = availableChampions
                            .map(champ => ({
                                name: champ,
                                winrate: meta[champ] || 0,
                                tier: getTierFromWinrate(meta[champ] || 0)
                            }))
                            .sort((a, b) => b.winrate - a.winrate);

                        // Prioritize S+ and S tier champions (if available)
                        const highTierChampions = sortedChampions.filter(c => c.tier === 'S+' || c.tier === 'S');
                        
                        if (highTierChampions.length > 0) {
                            // Select one of the highest tier champions randomly
                            const randomIndex = Math.floor(Math.random() * Math.min(3, highTierChampions.length));
                            championToBan = highTierChampions[randomIndex].name;
                            console.log('AI banning high tier champion:', championToBan, 
                                        'with winrate:', highTierChampions[randomIndex].winrate, 
                                        'tier:', highTierChampions[randomIndex].tier);
                        } else {
                            // If no S+ or S tier, select from top 3 highest winrate
                            const topIndex = Math.floor(Math.random() * Math.min(3, sortedChampions.length));
                            championToBan = sortedChampions[topIndex].name;
                            console.log('AI banning high winrate champion:', championToBan, 
                                        'with winrate:', sortedChampions[topIndex].winrate,
                                        'tier:', sortedChampions[topIndex].tier);
                        }
                    } else {
                        // 20% chance to ban a random champion (could be strategic or unexpected)
                        championToBan = availableChampions[Math.floor(Math.random() * availableChampions.length)];
                        console.log('AI banning random champion:', championToBan, 'with winrate:', meta[championToBan] || 0);
                    }

                    // Ban the selected champion
                    await banChampion(championToBan);
                    
                    // Update current ban team
                    currentBanTeam = currentBanTeam === 'blue' ? 'red' : 'blue';
                    
                    // Update phase info text
                    const phaseInfo = document.querySelector('.ban-phase-info p');
                    if (phaseInfo) {
                        phaseInfo.textContent = `${currentBanTeam.toUpperCase()} Team Ban Phase`;
                    }

                    // Show modal if it's player's turn to ban
                    if (currentBanTeam === playerTeam && isPlayerFirstPick()) {
                        document.getElementById('banModal').style.display = 'flex';
                    } else if (!banPhaseComplete) {
                        // If not player's turn and ban phase isn't complete, make another AI ban after a delay
                        setTimeout(makeAIBan, 1000);
                    }
                }
            } catch (error) {
                console.error('Error in makeAIBan:', error);
                // Fallback to random ban if there's an error
                const availableChampions = Array.from(new Set(
                    Object.values(roles).flat()
                )).filter(champ => !bannedChampions.has(champ));
                
                const randomChampion = availableChampions[Math.floor(Math.random() * availableChampions.length)];
                await banChampion(randomChampion);
            }
        }

        // Helper function to determine tier from winrate
        function getTierFromWinrate(winrate) {
            if (winrate >= 53) return 'S+';
            if (winrate >= 51) return 'S';
            if (winrate >= 49) return 'A';
            if (winrate >= 47) return 'B';
            if (winrate >= 45) return 'C';
            return 'D';
        }

        async function banChampion(champion) {
            console.log('Banning champion:', champion);
            
            // Check if champion is already banned
            if (bannedChampions.has(champion)) {
                console.log('Champion already banned:', champion);
                return;
            }

            // Check if team already has a ban
            const blueBanExists = document.getElementById('blueBanPortrait').querySelector('img');
            const redBanExists = document.getElementById('redBanPortrait').querySelector('img');
            
            if ((currentBanTeam === 'blue' && blueBanExists) || (currentBanTeam === 'red' && redBanExists)) {
                console.log(`${currentBanTeam} team already has a ban`);
                return;
            }
            
            // Add to banned set
            bannedChampions.add(champion);
            
            // Update ban portrait in the modal
            const banPortrait = document.getElementById(`${currentBanTeam}Ban`);
            if (banPortrait) {
                banPortrait.innerHTML = `<img src="Icons/${champion}.png" alt="${champion}">`;
                banPortrait.classList.remove('empty');
                banPortrait.classList.add('banned-champion');
            }

            // Update ban portrait in the header
            const headerPortrait = document.getElementById(`${currentBanTeam}BanPortrait`);
            if (headerPortrait) {
                headerPortrait.innerHTML = `<img src="Icons/${champion}.png" alt="${champion}">`;
                headerPortrait.classList.remove('empty');
            }

            // Update champion grid
            const championCards = document.querySelectorAll('.ban-card, .champion-card');
            championCards.forEach(card => {
                if (card.title === champion) {
                    card.classList.add('banned-champion');
                }
            });

            // Hide the ban modal
            document.getElementById('banModal').style.display = 'none';

            // Switch teams for banning
            currentBanTeam = currentBanTeam === 'blue' ? 'red' : 'blue';

            // Check if ban phase is complete (both teams have banned)
            if (document.getElementById('blueBanPortrait').querySelector('img') && 
                document.getElementById('redBanPortrait').querySelector('img')) {
                console.log('Ban phase complete');
                banPhaseComplete = true;
                document.getElementById('banModal').style.display = 'none';
                
                // Initialize champion grid and game only once
                initializeChampionGrid();
                initializeGame();
            } else {
                // If not complete and it's not player's turn, let AI make its ban
                if (currentBanTeam !== playerTeam || !isPlayerFirstPick()) {
                    setTimeout(makeAIBan, 500);
                } else {
                    // Show modal for player's ban
                    const modal = document.getElementById('banModal');
                    const phaseInfo = modal.querySelector('.ban-phase-info p');
                    phaseInfo.textContent = `Your turn to ban`;
                    modal.style.display = 'flex';
                }
            }
        }

        // ... existing code ...
        // Initialize data after processing the role
        selectedRole = null;
        playerTeam = team;
        playerSlot = slot;
        document.getElementById(`${team}-${slot}`).classList.add('player-slot');
        
        // Initialize game
        initializeGame();
        
        // Hide the modal
        document.getElementById('roleSelectModal').style.display = 'none';
    </script>
</body>
</html> 